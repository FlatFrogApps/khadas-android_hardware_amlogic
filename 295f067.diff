From 295f06707e1692a2b2104657072033157af8e20a Mon Sep 17 00:00:00 2001
From: Jinping Wang <jinping.wang@amlogic.com>
Date: Wed, 03 Jun 2020 10:56:15 +0800
Subject: [PATCH] NTS: audio hal update [1/15]

PD#GH-247
BUG=157718271

Problem:
sabrina NTS has a lot of fail, need to cherry_pick
CLs from HailStroms

Solution:
amlogic CL:
99571	audio: Fix NTS AV sync issue after HDMI plug [1/1]
100108	audio: refine audio hal system audio reported position jitter [1/2]
100201	audio: Fix video stuck issue after HDMI plug [1/1]
100205	audio: fix GTVS failure [1/1]
97523	audio: Fix google voice release the DTV patch [1/1]

Verify:
Sabrina platform

Signed-off-by: Jinping Wang <jinping.wang@amlogic.com>
Change-Id: I7bac1819eb349c6bde237de038ec021cd3e8eb23
---

diff --git a/audio/audio_hal/Android.mk b/audio/audio_hal/Android.mk
old mode 100755
new mode 100644
index 750c1da..3c6c33a
--- a/audio/audio_hal/Android.mk
+++ b/audio/audio_hal/Android.mk
@@ -77,7 +77,8 @@
         audio_virtual_buf.c \
         aml_audio_ease.c \
         aml_audio_spdifout.c \
-        aml_mmap_audio.c 
+        aml_mmap_audio.c \
+        aml_audio_ac3parser.c
 
 
     LOCAL_C_INCLUDES += \
diff --git a/audio/audio_hal/alsa_config_parameters.c b/audio/audio_hal/alsa_config_parameters.c
old mode 100755
new mode 100644
index cf7c960..f0563d2
--- a/audio/audio_hal/alsa_config_parameters.c
+++ b/audio/audio_hal/alsa_config_parameters.c
@@ -60,7 +60,7 @@
     hardware_config->rate = rate /* * 4 */;
     hardware_config->period_count = PLAYBACK_PERIOD_COUNT;
     hardware_config->period_size = PERIOD_SIZE * 4 * 2;
-    hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 2;
+    hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 4;
     hardware_config->avail_min = 0;
 
     return ;
@@ -77,9 +77,9 @@
     hardware_config->channels = 2;
     hardware_config->format = PCM_FORMAT_S16_LE;
     hardware_config->rate = rate;
-    hardware_config->period_count = PLAYBACK_PERIOD_COUNT;
+    hardware_config->period_count = PLAYBACK_PERIOD_COUNT * 2;
     hardware_config->period_size = PERIOD_SIZE;
-    hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count;
+    hardware_config->start_threshold = hardware_config->period_size * hardware_config->period_count / 4;
     hardware_config->avail_min = 0;
 
     return ;
diff --git a/audio/audio_hal/alsa_manager.c b/audio/audio_hal/alsa_manager.c
old mode 100755
new mode 100644
index ba0d5f1..7e66115
--- a/audio/audio_hal/alsa_manager.c
+++ b/audio/audio_hal/alsa_manager.c
@@ -42,8 +42,10 @@
 #define MAX_AVSYNC_GAP (10*90000)
 #define MAX_AVSYNC_WAIT_TIME (3*1000*1000)
 
-#define ALSA_OUT_BUF_NS (10000000000LL)   //10s
-#define ALSA_PREFILL_BUF_NS (10000000000LL)   //10s
+#define ALSA_OUT_BUF_NS (64000000LL)
+#define ALSA_DELAY_UP_THRESHOLD_MS (50)  /*the start threshold is 42ms, so we assume it as 50ms*/
+#define VIRTUAL_BUF_DELAY_PERIOD_MS (4)
+#define MS_TO_NANO_SEC  (1000000LL)
 
 
 /*
@@ -96,15 +98,35 @@
                 ALOGI("%s stream device(%d) differ with current device(%d)!", __func__, aml_out->device, device);
                 aml_out->is_device_differ_with_ms12 = true;
             }
+        } else {
+            audio_format_t output_format = aml_out->alsa_output_format;
+            get_hardware_config_parameters(
+                config
+                , output_format
+                , audio_channel_count_from_out_mask(aml_out->hal_channel_mask)
+                , aml_out->config.rate
+                , aml_out->is_tv_platform);
+            switch (output_format) {
+                case AUDIO_FORMAT_E_AC3:
+                    device = DIGITAL_DEVICE;
+                    break;
+                case AUDIO_FORMAT_AC3:
+                    device = DIGITAL_DEVICE;
+                    break;
+                case AUDIO_FORMAT_PCM_16_BIT:
+                default:
+                    device = I2S_DEVICE;
+                    break;
+            }
         }
     } else if (eDolbyDcvLib == adev->dolby_lib_type) {
         if (aml_out->dual_output_flag && adev->optical_format != AUDIO_FORMAT_PCM_16_BIT) {
             device = I2S_DEVICE;
             config->rate = MM_FULL_POWER_SAMPLING_RATE;
-        } else if (adev->sink_format != AUDIO_FORMAT_PCM_16_BIT &&
+        } else if (aml_out->alsa_output_format != AUDIO_FORMAT_PCM_16_BIT &&
                    aml_out->hal_format != AUDIO_FORMAT_PCM_16_BIT) {
             memset(&config_raw, 0, sizeof(struct pcm_config));
-            int period_mul = (adev->sink_format  == AUDIO_FORMAT_E_AC3) ? 4 : 1;
+            int period_mul = (aml_out->alsa_output_format  == AUDIO_FORMAT_E_AC3) ? 4 : 1;
             config_raw.channels = 2;
             config_raw.rate = aml_out->config.rate;//MM_FULL_POWER_SAMPLING_RATE ;
             config_raw.period_size = DEFAULT_PLAYBACK_PERIOD_SIZE * period_mul;
@@ -281,8 +303,7 @@
     int need_drop_inject = 0;
     int64_t pretime = 0;
     unsigned char*audio_data = (unsigned char*)buffer;
-
-    switch (adev->sink_format) {
+    switch (aml_out->alsa_output_format) {
     case AUDIO_FORMAT_E_AC3:
         frame_size = AUDIO_EAC3_FRAME_SIZE;
         break;
@@ -450,7 +471,6 @@
 
     {
         struct snd_pcm_status status;
-
         pcm_ioctl(aml_out->pcm, SNDRV_PCM_IOCTL_STATUS, &status);
         if (status.state == PCM_STATE_XRUN) {
             ALOGD("alsa underrun");
@@ -476,7 +496,9 @@
 
     ret = pcm_write(aml_out->pcm, buffer, bytes);
     if (ret < 0) {
-        ALOGE("%s write failed,pcm handle %p err num %d", __func__, aml_out->pcm, ret);
+        ALOGE("%s write failed,pcm handle %p %s, stream %p, %s",
+            __func__, aml_out->pcm, pcm_get_error(aml_out->pcm),
+            aml_out, usecase2Str(aml_out->usecase));
     }
 
     if ((adev->continuous_audio_mode == 1) && (eDolbyMS12Lib == adev->dolby_lib_type) && (bytes != 0)) {
@@ -495,10 +517,28 @@
         if (aml_out->alsa_vir_buf_handle == NULL) {
             /*set the buf to 10s, and then fill the buff, we will use this to make the data consuming to stable*/
             audio_virtual_buf_open(&aml_out->alsa_vir_buf_handle, "alsa out", ALSA_OUT_BUF_NS, ALSA_OUT_BUF_NS, 0);
-            audio_virtual_buf_process(aml_out->alsa_vir_buf_handle, ALSA_OUT_BUF_NS - input_ns/2);
+            audio_virtual_buf_process(aml_out->alsa_vir_buf_handle, ALSA_OUT_BUF_NS);
         }
-
         audio_virtual_buf_process(aml_out->alsa_vir_buf_handle, input_ns);
+
+        /* alsa output rate is not exactly with system time, we need check whether
+         * the delay is too big, if it is too big, we should delay the virtual buf
+         */
+        {
+            int rate_multiply = 1;
+            uint64_t frame_ms = 0;
+            snd_pcm_sframes_t frames = 0;
+            ret = pcm_ioctl(aml_out->pcm, SNDRV_PCM_IOCTL_DELAY, &frames);
+            if (aml_out->alsa_output_format == AUDIO_FORMAT_E_AC3) {
+                rate_multiply = 4;
+            }
+            frame_ms = (uint64_t)frames * 1000LL/ (sample_rate * rate_multiply);
+            ALOGV("alsa frame delay=%ld ms=%lld", frames, frame_ms);
+            if (frame_ms > ALSA_DELAY_UP_THRESHOLD_MS) {
+                ALOGI("alsa delay is =%lld catch up =%d", frame_ms, VIRTUAL_BUF_DELAY_PERIOD_MS);
+                audio_virtual_buf_process(aml_out->alsa_vir_buf_handle, VIRTUAL_BUF_DELAY_PERIOD_MS * MS_TO_NANO_SEC);
+            }
+        }
         if (mutex_lock_success) {
             pthread_mutex_lock(&adev->alsa_pcm_lock);
         }
diff --git a/audio/audio_hal/amlAudioMixer.c b/audio/audio_hal/amlAudioMixer.c
old mode 100755
new mode 100644
index 036f27b..8507603
--- a/audio/audio_hal/amlAudioMixer.c
+++ b/audio/audio_hal/amlAudioMixer.c
@@ -372,7 +372,7 @@
     } else if (in_port_system && in_port_system->notify_cbk_data) {
         out = (struct aml_stream_out *)in_port_system->notify_cbk_data;
     }
-
+    out_port->sound_track_mode = audio_mixer->adev->sound_track_mode;
     while (is_output_data_avail(audio_mixer, port_index)) {
         // out_write_callbacks();
         if (out && (out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP))
@@ -655,7 +655,6 @@
 {
     uint32_t frame_size = get_mixer_hwsync_frame_size(audio_mixer);
     uint32_t port_consumed_size = get_inport_consumed_size(in_port);
-    uint32_t aligned_offset = 0;
     int diff_ms = 0;
     struct hw_avsync_header header;
     int ret = 0;
@@ -670,7 +669,6 @@
         return -EINVAL;
     }
 
-    aligned_offset = hwsync_align_to_frame(port_consumed_size, frame_size);
     memset(&header, 0, sizeof(struct hw_avsync_header));
     ALOGV("direct out port bytes before cbk %d", get_outport_data_avail(out_port));
     if (!in_port->meta_data_cbk) {
@@ -679,7 +677,7 @@
     }
     ALOGV("%s(), port %p, data %p", __func__, in_port, in_port->meta_data_cbk_data);
     ret = in_port->meta_data_cbk(in_port->meta_data_cbk_data,
-                aligned_offset, &header, &diff_ms);
+                port_consumed_size, &header, &diff_ms);
     if (ret < 0) {
         if (ret != -EAGAIN)
             ALOGE("meta_data_cbk fail err = %d!!", ret);
diff --git a/audio/audio_hal/aml_audio_ac3parser.c b/audio/audio_hal/aml_audio_ac3parser.c
new file mode 100644
index 0000000..5ccf3b5
--- /dev/null
+++ b/audio/audio_hal/aml_audio_ac3parser.c
@@ -0,0 +1,577 @@
+/*
+ * Copyright (C) 2017 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define LOG_TAG "audio_ac3_parser"
+
+#include <cutils/log.h>
+#include "audio_hw.h"
+#include "audio_format_parse.h"
+#include "aml_audio_ac3parser.h"
+
+#define DOLBY_DDPP_MAXSIZE          (32768)
+#define DOLBY_DDP_HEADER_SIZE       (12)
+
+#define BYTE_REV(a) ((((uint16_t)a) & 0xff) << 8 | ((uint16_t)a) >> 8)
+
+/*====================*/
+/*merge from ffmpeg begin====*/
+
+/**
+ * Possible frame sizes.
+ * from ATSC A/52 Table 5.18 Frame Size Code Table.
+ */
+static const uint16_t ff_ac3_frame_size_tab[38][3] = {
+    { 64,   69,   96   },
+    { 64,   70,   96   },
+    { 80,   87,   120  },
+    { 80,   88,   120  },
+    { 96,   104,  144  },
+    { 96,   105,  144  },
+    { 112,  121,  168  },
+    { 112,  122,  168  },
+    { 128,  139,  192  },
+    { 128,  140,  192  },
+    { 160,  174,  240  },
+    { 160,  175,  240  },
+    { 192,  208,  288  },
+    { 192,  209,  288  },
+    { 224,  243,  336  },
+    { 224,  244,  336  },
+    { 256,  278,  384  },
+    { 256,  279,  384  },
+    { 320,  348,  480  },
+    { 320,  349,  480  },
+    { 384,  417,  576  },
+    { 384,  418,  576  },
+    { 448,  487,  672  },
+    { 448,  488,  672  },
+    { 512,  557,  768  },
+    { 512,  558,  768  },
+    { 640,  696,  960  },
+    { 640,  697,  960  },
+    { 768,  835,  1152 },
+    { 768,  836,  1152 },
+    { 896,  975,  1344 },
+    { 896,  976,  1344 },
+    { 1024, 1114, 1536 },
+    { 1024, 1115, 1536 },
+    { 1152, 1253, 1728 },
+    { 1152, 1254, 1728 },
+    { 1280, 1393, 1920 },
+    { 1280, 1394, 1920 },
+};
+
+/**
+ * Map audio coding mode (acmod) to number of full-bandwidth channels.
+ * from ATSC A/52 Table 5.8 Audio Coding Mode
+ */
+static const uint8_t ff_ac3_channels_tab[8] = {
+    2, 1, 2, 3, 3, 4, 4, 5
+};
+/** Channel mode (audio coding mode) */
+typedef enum {
+    AC3_CHMODE_DUALMONO = 0,
+    AC3_CHMODE_MONO,
+    AC3_CHMODE_STEREO,
+    AC3_CHMODE_3F,
+    AC3_CHMODE_2F1R,
+    AC3_CHMODE_3F1R,
+    AC3_CHMODE_2F2R,
+    AC3_CHMODE_3F2R
+} AC3ChannelMode;
+
+
+
+enum PARSER_STATE {
+    PARSER_SYNCING,
+    PARSER_SYNCED,
+    PARSER_LACK_DATA,
+};
+
+struct aml_ac3_parser {
+    void * buf;
+    int32_t buf_size;
+    int32_t buf_remain;
+    uint32_t status;
+    int32_t framesize;
+};
+
+int aml_ac3_parser_open(void **pparser_handle)
+{
+    struct aml_ac3_parser *parser_hanlde = NULL;
+
+    parser_hanlde = (struct aml_ac3_parser *)calloc(1, sizeof(struct aml_ac3_parser));
+    if (parser_hanlde == NULL) {
+        ALOGE("%s handle error", __func__);
+        goto error;
+    }
+
+    parser_hanlde->buf_size  = DOLBY_DDPP_MAXSIZE;
+    parser_hanlde->buf  = calloc(1, DOLBY_DDPP_MAXSIZE);
+    if (parser_hanlde->buf == NULL) {
+        ALOGE("%s data buffer error", __func__);
+        goto error;
+    }
+    parser_hanlde->status = PARSER_SYNCING;
+    parser_hanlde->buf_remain = 0;
+    *pparser_handle = parser_hanlde;
+    ALOGI("%s exit =%p", __func__, parser_hanlde);
+    return 0;
+error:
+    *pparser_handle = NULL;
+    ALOGE("%s error", __func__);
+    return -1;
+}
+int aml_ac3_parser_close(void *parser_handle)
+{
+    struct aml_ac3_parser *parser_hanlde = (struct aml_ac3_parser *)parser_handle;
+
+    if (parser_hanlde) {
+        if (parser_hanlde->buf) {
+            free(parser_hanlde->buf);
+        }
+        free(parser_hanlde);
+    }
+    ALOGE("%s exit", __func__);
+    return 0;
+}
+
+int aml_ac3_parser_reset(void *parser_handle)
+{
+    struct aml_ac3_parser *parser_hanlde = (struct aml_ac3_parser *)parser_handle;
+
+    if (parser_hanlde) {
+        parser_hanlde->status = PARSER_SYNCING;
+        parser_hanlde->buf_remain = 0;
+    }
+    ALOGE("%s exit", __func__);
+    return 0;
+}
+
+
+static int seek_dolby_sync_word(char *buffer, int size)
+{
+    int i = -1;
+
+    for (i = 0; i < (size - 1); i++) {
+        if (buffer[i + 0] == 0x0b && buffer[i + 1] == 0x77) {
+            return i;
+        }
+        if (buffer[i + 0] == 0x77 && buffer[i + 1] == 0x0b) {
+            return i;
+        }
+    }
+    return -1;
+}
+
+static int check_ac3_syncword(const unsigned char *ptr, int size)
+{
+    if (size < 2) {
+        return 0;
+    }
+    if (ptr[0] == 0x0b && ptr[1] == 0x77) {
+        return 1;
+    }
+    if (ptr[0] == 0x77 && ptr[1] == 0x0b) {
+        return 2;
+    }
+
+    return 0;
+}
+
+
+/*
+ *parse frame header[ATSC Standard,Digital Audio Compression (AC-3, E-AC-3)]
+ */
+static int parse_dolby_frame_header
+(const unsigned char *frameBuf
+ , int length
+ , int *frame_offset
+ , int *frame_size
+ , int *channel_num
+ , int *numblks
+ , int *timeslice_61937
+ , int *framevalid_flag
+ , int *frame_dependent)
+{
+    int acmod = 0;
+    int lfeOn = 0;
+    int nIsEc3 = 0;
+    int frame_size_code = 0;
+    int sr_code = 0;
+    int substreamid = 0;
+    int numblk_per_frame;
+    char inheader[12] = {0};
+    int offset = 0;
+    int header = 0;
+    int i = 0;
+    *channel_num = 2;
+
+    /*TODO, used to correct iec61937 packet*/
+    *timeslice_61937 = 0;
+    *framevalid_flag = 0;
+    *frame_dependent = 0;
+
+    for (i = 0; i < length; ++i) {
+        if ((header = check_ac3_syncword(&frameBuf[i], length - i)) > 0) {
+            offset = i;
+            break;
+        }
+    }
+    /*step 1, frame header 0x0b77/0x770b*/
+    if (header == 0) {
+        //ALOGE("locate frame header 0x0b77/0x770b failed\n");
+        goto error;/*no frame header, maybe need more data*/
+    }
+
+    /*step 2, copy 12bytes to inheader,  find one frame*/
+    if (length - offset < 12) {
+        /*
+         *find the sync word 0x0b77/0x770b,
+         *but we need 12bytes which will copy to inheader[12], need more data
+         */
+        ALOGE("data less than one frame!!!\n");
+        goto error;
+    } else {
+        memcpy((void *) inheader, (const void *)(frameBuf + offset), 12);
+    }
+
+    if (header == 2) {
+        int16_t *p_data = (int16_t *) inheader;
+        unsigned int idx;
+        unsigned int inheader_len = 12;
+        unsigned int top = inheader_len / 2;
+        for (idx = 0; idx < top; idx++) {
+            p_data[idx] = (int16_t) BYTE_REV(p_data[idx]);
+        }
+    }
+
+    if (length < 12) {
+        ALOGE("%s len %d\n", __FUNCTION__, length);
+        goto error;
+    } else {
+        //ALOGV("dolby head:0x%x 0x%x 0x%x 0x%x 0x%x 0x%x \n",
+        //    inheader[0],inheader[1],inheader[2], inheader[3],inheader[4],inheader[5]);
+        int bsid = (inheader[5] >> 3) & 0x1f;//bitstream_id,bit[40,44]
+        if (bsid > 16) {
+            goto error;    //invalid bitstream_id
+        }
+        if (bsid <= 8) {
+            nIsEc3 = 0;
+        } else if ((bsid <= 16) && (bsid > 10)) {
+            nIsEc3 = 1;
+        }
+
+        if (nIsEc3 == 0) {
+            int use_bits = 0;
+
+            substreamid = 0;
+            sr_code = inheader[4] >> 6;
+            if (sr_code == 3) {
+                ALOGE("%s error *sr_code %d", __FUNCTION__, sr_code);
+                goto error;
+            }
+            frame_size_code = inheader[4] & 0x3F;
+            if (frame_size_code > 37) {
+                ALOGE("%s error frame_size_code %d", __FUNCTION__, frame_size_code);
+                goto error;
+            }
+            acmod = (inheader[6] >> 5) & 0x7;// 3bits
+            use_bits = use_bits + 3;
+            if (acmod == AC3_CHMODE_STEREO) {
+                //int dolby_surround_mode = (inheader[6] >> 3) &0x3; // 2bits
+                use_bits = use_bits + 2;
+            } else {
+                if ((acmod & 1)  && (acmod != AC3_CHMODE_MONO)) {
+                    //int center_mix_level =  center_levels[ (inheader[6] >> 3) &0x3]; // 2bits
+                    use_bits = use_bits + 2;
+                }
+                if (acmod & 4) {
+                    //int surround_mix_level = surround_levels[ (inheader[6] >> 1) &0x3]; // 2bits
+                    use_bits = use_bits + 2;
+                }
+            }
+            lfeOn = (inheader[6] >> (8 - use_bits - 1)) & 0x1; // 1bit
+            *frame_size = ff_ac3_frame_size_tab[frame_size_code][sr_code] * 2;
+            numblk_per_frame = 6;
+            *numblks = numblk_per_frame;
+            *timeslice_61937 = 1;
+            *framevalid_flag = 1;
+        } else {
+            int numblkscod = 0;
+            int strmtyp = (inheader[2] >> 6) & 0x3;
+            int substreamid = (inheader[2] >> 3) & 0x7;
+            *frame_size = ((inheader[2] & 0x7) * 0x100 + inheader[3] + 1) << 1;
+            sr_code = inheader[4] >> 6;
+            acmod = (inheader[4] >> 1) & 0x7;
+            lfeOn = inheader[4] & 0x1;
+            numblkscod = (sr_code == 0x3) ? 0x3 : ((inheader[4] >> 4) & 0x3);
+            numblk_per_frame = (numblkscod == 0x3) ? 6 : (numblkscod + 1);
+            ALOGV("%s() ec3 numblkscod %d numblk_per_frame %d substreamid %d strmtyp %d\n",
+                  __FUNCTION__, numblkscod, numblk_per_frame, substreamid, strmtyp);
+            if (substreamid == 0 && strmtyp == 0) {
+                if (*framevalid_flag == 0) {
+                    *timeslice_61937 = 0;
+                    // *numblks += numblk_per_frame;
+                    *framevalid_flag = 1;
+                } else if (*framevalid_flag == 1) {
+                    if (*numblks  == 6) {
+                        *timeslice_61937 = 1;
+                        // *numblks = numblk_per_frame;
+                    } else if (*numblks  > 6) {
+                        *timeslice_61937 = 2;
+                        // *numblks = numblk_per_frame;
+                    } else {
+                        *timeslice_61937 = 0;
+                        // *numblks += numblk_per_frame;
+                    }
+                }
+            } else if (strmtyp == 1) {
+                *timeslice_61937 = 3;
+            }
+            *numblks = numblk_per_frame;
+            *frame_dependent = strmtyp;
+
+        }
+        // ALOGV("%s acmod %d lfeOn %d\n", nIsEc3==0?"ac3":"ec3",acmod, lfeOn);
+        *channel_num = ff_ac3_channels_tab[acmod] + lfeOn;
+    }
+    *frame_offset = offset;
+    ALOGV("%s frame_offset %d frame_size %d channel_num %d numblks %d timeslice_61937 %d framevalid_flag %d\n",
+          __FUNCTION__, *frame_offset, *frame_size, *channel_num, *numblks, *timeslice_61937, *framevalid_flag);
+
+    return 0;
+error:
+    *frame_offset = 0;
+    return 1;
+}
+
+
+int aml_ac3_parser_process(void *parser_handle, const void *in_buffer, int32_t numBytes, int32_t *used_size, void **output_buf, int32_t *out_size, struct ac3_parser_info * ac3_info)
+{
+    struct aml_ac3_parser *parser_hanlde = (struct aml_ac3_parser *)parser_handle;
+    size_t remain = 0;
+    uint8_t *buffer = (uint8_t *)in_buffer;
+    uint8_t * parser_buf = NULL;
+    int32_t sync_word_offset = -1;
+    int32_t buf_left = 0;
+    int32_t buf_offset = 0;
+    int32_t need_size = 0;
+
+    int32_t ret = 0;
+    int32_t data_valid = 0;
+    int32_t new_buf_size = 0;
+    int32_t loop_cnt = 0;
+    int32_t frame_size = 0;
+    int32_t frame_offset = 0;
+
+    if (parser_hanlde == NULL) {
+        goto error;
+    }
+
+    if (ac3_info == NULL) {
+        goto error;
+    }
+
+    memset(ac3_info, 0, sizeof(struct ac3_parser_info));
+
+    parser_buf = parser_hanlde->buf;
+    buf_left     = numBytes;
+
+    ALOGV("%s input buf size=%d status=%d", __func__, numBytes, parser_hanlde->status);
+
+    /*we need at least 12 bytes*/
+    if (parser_hanlde->buf_remain < DOLBY_DDP_HEADER_SIZE) {
+        need_size = DOLBY_DDP_HEADER_SIZE - parser_hanlde->buf_remain;
+        /*input data is not enough, just copy to internal buf*/
+        if (buf_left < need_size) {
+            memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, buf_left);
+            parser_hanlde->buf_remain += buf_left;
+            goto error;
+        }
+        /*make sure the remain buf has 12 bytes*/
+        memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, need_size);
+        parser_hanlde->buf_remain += need_size;
+        buf_offset += need_size;
+        buf_left   = numBytes - buf_offset;
+
+    }
+
+    if (parser_hanlde->status == PARSER_SYNCING) {
+        sync_word_offset = -1;
+        while (sync_word_offset < 0) {
+            /*sync the header, we have at least period bytes*/
+            if (parser_hanlde->buf_remain < DOLBY_DDP_HEADER_SIZE) {
+                ALOGE("we should not get there");
+                parser_hanlde->buf_remain = 0;
+                goto error;
+            }
+            sync_word_offset = seek_dolby_sync_word((char*)parser_buf, parser_hanlde->buf_remain);
+            /*if we don't find the header in period bytes, move the last 1 bytes to header*/
+            if (sync_word_offset < 0) {
+                memmove(parser_buf, parser_buf + parser_hanlde->buf_remain - 1, 1);
+                parser_hanlde->buf_remain = 1;
+                need_size = DOLBY_DDP_HEADER_SIZE - parser_hanlde->buf_remain;
+                /*input data is not enough, just copy to internal buf*/
+                if (buf_left < need_size) {
+                    memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, buf_left);
+                    parser_hanlde->buf_remain += buf_left;
+                    /*don't find the header, and there is no enough data*/
+                    goto error;
+                }
+                /*make the buf has 12 bytes*/
+                memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, need_size);
+                parser_hanlde->buf_remain += need_size;
+                buf_offset += need_size;
+                buf_left = numBytes - buf_offset;
+            }
+            loop_cnt++;
+        }
+        /*got here means we find the sync word*/
+        parser_hanlde->status = PARSER_SYNCED;
+
+        data_valid = parser_hanlde->buf_remain - sync_word_offset;
+        /*move the header to the beginning of buf*/
+        if (sync_word_offset != 0) {
+            memmove(parser_buf, parser_buf + sync_word_offset, data_valid);
+        }
+        parser_hanlde->buf_remain = data_valid;
+
+        need_size = DOLBY_DDP_HEADER_SIZE - data_valid;
+        /*get some bytes to make sure it is at least 12 bytes*/
+        if (need_size > 0) {
+            /*check if input has enough data*/
+            if (buf_left < need_size) {
+                memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, buf_left);
+                parser_hanlde->buf_remain += buf_left;
+                goto error;
+            }
+            /*make sure the remain buf has 12 bytes*/
+            memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset , need_size);
+            parser_hanlde->buf_remain += need_size;
+            buf_offset += need_size;
+            buf_left = numBytes - buf_offset;
+        }
+
+
+    }
+
+    /*double check here*/
+    sync_word_offset = seek_dolby_sync_word((char*)parser_buf, parser_hanlde->buf_remain);
+    if (sync_word_offset != 0) {
+        ALOGE("we can't get here remain=%d,resync dolby header", parser_hanlde->buf_remain);
+        parser_hanlde->buf_remain = 0;
+        parser_hanlde->status = PARSER_SYNCING;
+        goto error;
+    }
+    /* we got here means we find the dolby header and
+     * it is at the beginning of  parser buf and
+     * it has at least 12 bytes, we can parse it
+     */
+    ret = parse_dolby_frame_header(parser_buf, parser_hanlde->buf_remain,  &frame_offset, &ac3_info->frame_size,
+                                   &ac3_info->channel_num, &ac3_info->numblks, &ac3_info->timeslice_61937,
+                                   &ac3_info->framevalid_flag,
+                                   &ac3_info->frame_dependent);
+
+
+
+    /*check whether the input data has a complete ac3 frame*/
+    if (ac3_info->frame_size == 0) {
+        ALOGE("%s wrong frame size=%d", __func__, ac3_info->frame_size);
+        parser_hanlde->buf_remain = 0;
+        parser_hanlde->status = PARSER_SYNCING;
+        goto error;
+    }
+
+    frame_size = ac3_info->frame_size;
+
+    /*we have a complete payload*/
+    if ((parser_hanlde->buf_remain + buf_left) >= frame_size) {
+        need_size = frame_size - (parser_hanlde->buf_remain);
+        if (need_size >= 0) {
+            new_buf_size = parser_hanlde->buf_remain + need_size;
+            if (new_buf_size > parser_hanlde->buf_size) {
+                parser_hanlde->buf = realloc(parser_hanlde->buf, new_buf_size);
+                if (parser_hanlde->buf == NULL) {
+                    ALOGE("%s realloc buf failed =%d", __func__, new_buf_size);
+                    parser_hanlde->buf_remain = 0;
+                    parser_hanlde->status = PARSER_SYNCING;
+                    goto error;
+                }
+                parser_hanlde->buf_size = new_buf_size;
+                parser_buf = parser_hanlde->buf;
+                ALOGI("%s realloc buf =%d", __func__, new_buf_size);
+            }
+
+            memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, need_size);
+            buf_offset += need_size;
+            buf_left = numBytes - buf_offset;
+
+            *output_buf = (void*)(parser_buf);
+            *out_size   = frame_size;
+            *used_size = buf_offset;
+            ALOGV("OK framesize =%d used size=%d loop_cnt=%d", frame_size, buf_offset, loop_cnt);
+            /*one frame has complete, need find next one*/
+            parser_hanlde->buf_remain = 0;
+            parser_hanlde->status = PARSER_SYNCING;
+        } else {
+            /*internal buf has more data than framsize, we only need part of it*/
+            *output_buf = (void*)(parser_buf);
+            *out_size   = frame_size;
+            /*move need_size bytes back to original buf*/
+            *used_size = buf_offset + need_size;
+            ALOGV("wrap frame size=%d used size=%d back size =%d loop_cnt=%d", frame_size, buf_offset, need_size, loop_cnt);
+            if (*used_size <= 0) {
+                ALOGE("%s wrong used size =%d", __func__, *used_size);
+                parser_hanlde->buf_remain = 0;
+                parser_hanlde->status = PARSER_SYNCING;
+                goto error;
+            }
+            /*one frame has complete, need find next one*/
+            parser_hanlde->buf_remain = 0;
+            parser_hanlde->status = PARSER_SYNCING;
+        }
+    } else {
+        /*check whether the input buf size is big enough*/
+        new_buf_size = parser_hanlde->buf_remain + buf_left;
+        if (new_buf_size > parser_hanlde->buf_size) {
+            parser_hanlde->buf = realloc(parser_hanlde->buf, new_buf_size);
+            if (parser_hanlde->buf == NULL) {
+                ALOGE("%s realloc buf failed =%d", __func__, new_buf_size);
+                parser_hanlde->buf_remain = 0;
+                parser_hanlde->status = PARSER_SYNCING;
+                goto error;
+            }
+            parser_hanlde->buf_size = new_buf_size;
+            parser_buf = parser_hanlde->buf;
+            ALOGI("%s realloc buf =%d", __func__, new_buf_size);
+        }
+        memcpy(parser_buf + parser_hanlde->buf_remain, buffer + buf_offset, buf_left);
+        parser_hanlde->buf_remain += buf_left;
+        parser_hanlde->status = PARSER_LACK_DATA;
+        goto error;
+    }
+    if (parser_hanlde->framesize != frame_size) {
+        parser_hanlde->framesize = frame_size;
+        ALOGI("New frame size =%d", frame_size);
+    }
+    return 0;
+
+error:
+    *output_buf = NULL;
+    *out_size   = 0;
+    *used_size = numBytes;
+    return 0;
+}
diff --git a/audio/audio_hal/aml_audio_ac3parser.h b/audio/audio_hal/aml_audio_ac3parser.h
new file mode 100644
index 0000000..f67675f
--- /dev/null
+++ b/audio/audio_hal/aml_audio_ac3parser.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2017 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _AML_AUDIO_AC3PARSER_H_
+#define _AML_AUDIO_AC3PARSER_H_
+
+struct ac3_parser_info {
+    int frame_size;
+    int channel_num;
+    int numblks;
+    int timeslice_61937;
+    int framevalid_flag;
+    int frame_dependent;
+};
+
+
+int aml_ac3_parser_open(void **pparser_handle);
+int aml_ac3_parser_close(void *parser_handle);
+int aml_ac3_parser_process(void *parser_handle, const void *buffer, int32_t numBytes, int32_t *used_size, void **output_buf, int32_t *out_size, struct ac3_parser_info * ac3_info);
+int aml_ac3_parser_reset(void *parser_handle);
+
+
+#endif
diff --git a/audio/audio_hal/aml_audio_avsync_table.h b/audio/audio_hal/aml_audio_avsync_table.h
new file mode 100644
index 0000000..1825bb3
--- /dev/null
+++ b/audio/audio_hal/aml_audio_avsync_table.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2020 Amlogic Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+#ifndef  _AUDIO_AVSYNC_TABLE_H_
+#define _AUDIO_AVSYNC_TABLE_H_
+
+/* we use this table to tune the AV sync case for NTS,
+ * if the value is big, it can delay video
+ * if the value is small, it can advance the video
+ */
+
+/*below MS12 tunning is for roku tv*/
+#define  AVSYNC_MS12_NONTUNNEL_PCM_LATENCY               (90)
+#define  AVSYNC_MS12_NONTUNNEL_RAW_LATENCY               (15)
+#define  AVSYNC_MS12_NONTUNNEL_ATMOS_LATENCY             (25)
+#define  AVSYNC_MS12_TUNNEL_PCM_LATENCY                  (85)
+#define  AVSYNC_MS12_TUNNEL_RAW_LATENCY                  (80)
+#define  AVSYNC_MS12_TUNNEL_ATMOS_LATENCY                (20)
+
+
+#define  AVSYNC_MS12_NONTUNNEL_PCM_LATENCY_PROPERTY      "vendor.media.audio.hal.ms12.nontunnel.pcm"
+#define  AVSYNC_MS12_NONTUNNEL_RAW_LATENCY_PROPERTY      "vendor.media.audio.hal.ms12.nontunnel.raw"
+#define  AVSYNC_MS12_NONTUNNEL_ATMOS_LATENCY_PROPERTY    "vendor.media.audio.hal.ms12.nontunnel.atmos"
+#define  AVSYNC_MS12_TUNNEL_PCM_LATENCY_PROPERTY         "vendor.media.audio.hal.ms12.tunnel.pcm"
+#define  AVSYNC_MS12_TUNNEL_RAW_LATENCY_PROPERTY         "vendor.media.audio.hal.ms12.tunnel.raw"
+#define  AVSYNC_MS12_TUNNEL_ATMOS_LATENCY_PROPERTY       "vendor.media.audio.hal.ms12.tunnel.atmos"
+
+
+/*below DDP tunning is for roku tv*/
+#define  AVSYNC_DDP_NONTUNNEL_PCM_LATENCY               (0)
+#define  AVSYNC_DDP_NONTUNNEL_RAW_LATENCY               (0)
+#define  AVSYNC_DDP_TUNNEL_PCM_LATENCY                  (0)
+#define  AVSYNC_DDP_TUNNEL_RAW_LATENCY                  (0)
+
+
+#define  AVSYNC_DDP_NONTUNNEL_PCM_LATENCY_PROPERTY      "vendor.media.audio.hal.ddp.nontunnel.pcm"
+#define  AVSYNC_DDP_NONTUNNEL_RAW_LATENCY_PROPERTY      "vendor.media.audio.hal.ddp.nontunnel.raw"
+#define  AVSYNC_DDP_TUNNEL_PCM_LATENCY_PROPERTY         "vendor.media.audio.hal.ddp.tunnel.pcm"
+#define  AVSYNC_DDP_TUNNEL_RAW_LATENCY_PROPERTY         "vendor.media.audio.hal.ddp.tunnel.raw"
+
+
+
+#endif
+
diff --git a/audio/audio_hal/aml_audio_mixer.c b/audio/audio_hal/aml_audio_mixer.c
old mode 100755
new mode 100644
index 34d87a1..4f1fe0c
--- a/audio/audio_hal/aml_audio_mixer.c
+++ b/audio/audio_hal/aml_audio_mixer.c
@@ -1011,7 +1011,7 @@
     enum MIXER_INPUT_PORT port_index = 0;
     for (port_index = 0; port_index < MIXER_INPUT_PORT_NUM; port_index++) {
         struct input_port *in_port = audio_mixer->in_ports[port_index];
-        if (in_port && in_port->on_notify_cbk)
+        if (in_port && in_port->on_input_avail_cbk)
             in_port->on_input_avail_cbk(in_port->input_avail_cbk_data);
     }
 
diff --git a/audio/audio_hal/aml_audio_spdifout.c b/audio/audio_hal/aml_audio_spdifout.c
index 9e8aaec..aaf3587 100644
--- a/audio/audio_hal/aml_audio_spdifout.c
+++ b/audio/audio_hal/aml_audio_spdifout.c
@@ -106,12 +106,11 @@
     int spdif_format_ctr_id = AML_MIXER_ID_SPDIF_FORMAT;
     int spdif_to_hdmi_select = AML_SPDIF_A_TO_HDMITX;
 
-    if ((spdif_port != PORT_SPDIF) && (spdif_port != PORT_SPDIFB) && spdif_port != PORT_I2S2HDMI) {
+    if ((spdif_port != PORT_SPDIF) && (spdif_port != PORT_SPDIFB)) {
         return;
     }
 
-    /* i2s2hdmi multi-ch use spdifa fmt too */
-    if (spdif_port == PORT_SPDIF || spdif_port == PORT_I2S2HDMI) {
+    if (spdif_port == PORT_SPDIF) {
         spdif_format_ctr_id = AML_MIXER_ID_SPDIF_FORMAT;
     } else if (spdif_port == PORT_SPDIFB) {
         spdif_format_ctr_id = AML_MIXER_ID_SPDIF_B_FORMAT;
@@ -120,7 +119,7 @@
     aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, spdif_format_ctr_id, aml_spdif_format);
 
     /*use same source for normal pcm case*/
-    if (aml_spdif_format == AML_STEREO_PCM || aml_spdif_format == AML_MULTI_CH_LPCM) {
+    if (aml_spdif_format == AML_STEREO_PCM) {
         aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_SPDIF_TO_HDMI,  AML_SPDIF_A_TO_HDMITX);
         aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_SPDIF_FORMAT, aml_spdif_format);
         aml_mixer_ctrl_set_int(&aml_dev->alsa_mixer, AML_MIXER_ID_SPDIF_B_FORMAT, aml_spdif_format);
diff --git a/audio/audio_hal/aml_audio_stream.c b/audio/audio_hal/aml_audio_stream.c
old mode 100755
new mode 100644
index fffc24c..1605b34
--- a/audio/audio_hal/aml_audio_stream.c
+++ b/audio/audio_hal/aml_audio_stream.c
@@ -387,3 +387,111 @@
     return true;
 }
 
+const char *audio_port_role[] = {
+    "AUDIO_PORT_ROLE_NONE",
+    "AUDIO_PORT_ROLE_SOURCE",
+    "AUDIO_PORT_ROLE_SINK",
+};
+const char *audio_port_role_to_str(audio_port_role_t role)
+{
+    if (role > AUDIO_PORT_ROLE_SINK)
+        return NULL;
+
+    return audio_port_role[role];
+}
+
+const char *audio_port_type[] = {
+    "AUDIO_PORT_TYPE_NONE",
+    "AUDIO_PORT_TYPE_DEVICE",
+    "AUDIO_PORT_TYPE_MIX",
+    "AUDIO_PORT_TYPE_SESSION",
+};
+
+const char *audio_port_type_to_str(audio_port_type_t type)
+{
+    if (type > AUDIO_PORT_TYPE_SESSION)
+        return NULL;
+
+    return audio_port_type[type];
+}
+
+const char *write_func_strs[MIXER_WRITE_FUNC_MAX] = {
+    "OUT_WRITE_NEW",
+    "MIXER_AUX_BUFFER_WRITE_SM",
+    "MIXER_AUX_BUFFER_WRITE",
+    "MIXER_MAIN_BUFFER_WRITE"
+};
+
+static const char *write_func_to_str(enum stream_write_func func)
+{
+    return write_func_strs[func];
+}
+
+void aml_stream_out_dump(struct aml_stream_out *aml_out, int fd)
+{
+    if (aml_out) {
+        dprintf(fd, "    usecase: %s\n", usecase2Str(aml_out->usecase));
+        dprintf(fd, "    out device: %#x\n", aml_out->out_device);
+        dprintf(fd, "    tv source stream: %d\n", aml_out->tv_src_stream);
+        dprintf(fd, "    status: %d\n", aml_out->status);
+        dprintf(fd, "    standby: %d\n", aml_out->standby);
+        if (aml_out->is_normal_pcm) {
+            dprintf(fd, "    normal pcm: %s\n",
+                write_func_to_str(aml_out->write_func));
+        }
+    }
+}
+
+void aml_audio_port_config_dump(struct audio_port_config *port_config, int fd)
+{
+    if (port_config == NULL)
+        return;
+
+    dprintf(fd, "\t-id(%d), role(%s), type(%s)\n", port_config->id, audio_port_role[port_config->role], audio_port_type[port_config->type]);
+    switch (port_config->type) {
+    case AUDIO_PORT_TYPE_DEVICE:
+        dprintf(fd, "\t-port device: type(%#x) addr(%s)\n",
+               port_config->ext.device.type, port_config->ext.device.address);
+        break;
+    case AUDIO_PORT_TYPE_MIX:
+        dprintf(fd, "\t-port mix: iohandle(%d)\n", port_config->ext.mix.handle);
+        break;
+    default:
+        break;
+    }
+}
+
+void aml_audio_patch_dump(struct audio_patch *patch, int fd)
+{
+    int i = 0;
+
+    dprintf(fd, " handle %d\n", patch->id);
+    for (i = 0; i < patch->num_sources; i++) {
+        dprintf(fd, "    [src  %d]\n", i);
+        aml_audio_port_config_dump(&patch->sources[i], fd);
+    }
+
+    for (i = 0; i < patch->num_sinks; i++) {
+        dprintf(fd, "    [sink %d]\n", i);
+        aml_audio_port_config_dump(&patch->sinks[i], fd);
+    }
+}
+
+void aml_audio_patches_dump(struct aml_audio_device* aml_dev, int fd)
+{
+    struct audio_patch_set *patch_set = NULL;
+    struct audio_patch *patch = NULL;
+    struct listnode *node = NULL;
+    int i = 0;
+
+    dprintf(fd, "\nAML Audio Patches:\n");
+    list_for_each(node, &aml_dev->patch_list) {
+        dprintf(fd, "  patch %d:", i);
+        patch_set = node_to_item (node, struct audio_patch_set, list);
+        if (patch_set)
+            aml_audio_patch_dump(&patch_set->audio_patch, fd);
+
+        i++;
+    }
+}
+
diff --git a/audio/audio_hal/aml_audio_stream.h b/audio/audio_hal/aml_audio_stream.h
old mode 100755
new mode 100644
index 46d0aaf..3d48686
--- a/audio/audio_hal/aml_audio_stream.h
+++ b/audio/audio_hal/aml_audio_stream.h
@@ -66,12 +66,21 @@
     AUTO = 5
 };
 
+enum stream_write_func {
+    OUT_WRITE_NEW = 0,
+    MIXER_AUX_BUFFER_WRITE_SM = 1,
+    MIXER_AUX_BUFFER_WRITE = 2,
+    MIXER_MAIN_BUFFER_WRITE = 3,
+    MIXER_WRITE_FUNC_MAX
+};
+
 /**\brief Audio output mode*/
 typedef enum {
     AM_AOUT_OUTPUT_STEREO,     /**< Stereo output*/
     AM_AOUT_OUTPUT_DUAL_LEFT,  /**< Left audio output to dual channel*/
     AM_AOUT_OUTPUT_DUAL_RIGHT, /**< Right audio output to dual channel*/
-    AM_AOUT_OUTPUT_SWAP        /**< Swap left and right channel*/
+    AM_AOUT_OUTPUT_SWAP,        /**< Swap left and right channel*/
+    AM_AOUT_OUTPUT_LRMIX       /**< mix left and right channel*/
 } AM_AOUT_OutputMode_t;
 static inline bool is_main_write_usecase(stream_usecase_t usecase)
 {
@@ -276,6 +285,12 @@
 	AM_AOUT_OutputMode_t   mode;
     bool ac3_pcm_dropping;
     int last_audio_delay;
+    //add only for debug.
+    int dtv_log_retry_cnt;
+    unsigned int last_apts_record;
+    unsigned int last_vpts_record;
+    unsigned int last_pcrpts_record;
+    struct timespec last_debug_record;
 };
 
 struct audio_stream_out;
@@ -314,4 +329,12 @@
 /*@brief check the AV audio stability by HW register */
 bool is_av_in_stable_hw(struct audio_stream_in *stream);
 bool is_dual_output_stream(struct audio_stream_out *stream);
+/* dumpsys media.audio_flinger interfaces */
+const char *audio_port_role_to_str(audio_port_role_t role);
+const char *audio_port_type_to_str(audio_port_type_t type);
+void aml_stream_out_dump(struct aml_stream_out *aml_out, int fd);
+void aml_audio_port_config_dump(struct audio_port_config *port_config, int fd);
+void aml_audio_patch_dump(struct audio_patch *patch, int fd);
+void aml_audio_patches_dump(struct aml_audio_device* aml_dev, int fd);
+
 #endif /* _AML_AUDIO_STREAM_H_ */
diff --git a/audio/audio_hal/aml_mmap_audio.c b/audio/audio_hal/aml_mmap_audio.c
old mode 100755
new mode 100644
index c074e06..11f62ff
--- a/audio/audio_hal/aml_mmap_audio.c
+++ b/audio/audio_hal/aml_mmap_audio.c
@@ -37,6 +37,7 @@
 #define MMAP_BUFFER_SIZE_BYTE           (MMAP_SAMPLE_RATE_HZ * MMAP_FRAME_SIZE_BYTE * 32 / 1000)
 #define MMAP_WRITE_SIZE_BYTE            (MMAP_SAMPLE_RATE_HZ * MMAP_FRAME_SIZE_BYTE * 8 / 1000)  // every time to write 8ms data
 #define MMAP_WRITE_SIZE_FRAME           (MMAP_WRITE_SIZE_BYTE / MMAP_FRAME_SIZE_BYTE)
+#define MMAP_SAMPLE_RATE_HZ             (48000)
 #define MMAP_WRITE_PERIOD_TIME_NANO     (MMAP_WRITE_SIZE_FRAME * 1000000000LL / MMAP_SAMPLE_RATE_HZ)
 
 enum {
diff --git a/audio/audio_hal/audio_hw.c b/audio/audio_hal/audio_hw.c
old mode 100755
new mode 100644
index 307b0c3..e74dfdb
--- a/audio/audio_hal/audio_hw.c
+++ b/audio/audio_hal/audio_hw.c
@@ -80,6 +80,7 @@
 #include <SPDIFEncoderAD.h>
 #include "audio_hw_ms12.h"
 #include "dolby_lib_api.h"
+#include "aml_audio_ac3parser.h"
 
 #define ENABLE_NANO_NEW_PATH 1
 #if ENABLE_NANO_NEW_PATH
@@ -764,7 +765,6 @@
             /* our hw only support 8 channel configure,so when 5.1,hw mask the last two channels*/
             sysfs_set_sysfs_str ("/sys/class/amhdmitx/amhdmitx0/aud_output_chs", "6:7");
             out->config.channels = 8;
-            port = PORT_I2S;
         }
     }
     /*
@@ -772,6 +772,8 @@
     * PCM_FORMAT_S32_LE
     */
     if (!format_is_passthrough(out->hal_format) && (out->config.channels == 8)) {
+        port = PORT_I2S;
+        out->config.format = PCM_FORMAT_S32_LE;
         adev->out_device = AUDIO_DEVICE_OUT_SPEAKER;
         ALOGI ("[%s %d]8CH format output: set port/0 adev->out_device/%d\n",
                __FUNCTION__, __LINE__, AUDIO_DEVICE_OUT_SPEAKER);
@@ -818,6 +820,8 @@
                 /*ddp case doesn't support dual output, we always use spdif_a*/
                 port = aml_audio_get_spdifa_port();
             }
+            else
+                port = PORT_I2S;
         }
         aml_audio_set_spdif_format(port, (eMixerSpdif_Format)codec_type, out);
         aml_audio_select_spdif_to_hdmi(AML_SPDIF_A_TO_HDMITX);
@@ -863,7 +867,14 @@
                 ALOGE("%s() aml_spdif_encoder_open failed", __func__);
                 return -EINVAL;
             }
-            out->spdifenc_init = 1;
+            out->spdifenc_init = true;
+
+            ret = aml_ac3_parser_open(&out->ac3_parser_handle);
+            if (ret) {
+                ALOGE("%s() aml_ac3_parser_open failed", __func__);
+                return -EINVAL;
+            }
+            out->ac3_parser_init = true;
         }
     }
 
@@ -1070,7 +1081,8 @@
                 size = (8192 + 20);
                 return size;
             } else {
-                return DEFAULT_PLAYBACK_PERIOD_SIZE * 2 * audio_stream_out_frame_size ( (struct audio_stream_out *) stream);
+                /* roll back the change for SWPL-15974 to pass the gts failure SWPL-20926*/
+                return DEFAULT_PLAYBACK_PERIOD_SIZE * PLAYBACK_PERIOD_COUNT* audio_stream_out_frame_size ( (struct audio_stream_out *) stream);
             }
         }
         if (out->config.rate == 96000)
@@ -1300,6 +1312,9 @@
     if (out->need_convert) {
         ALOGI("need_convert release %d ",__LINE__);
         dcv_decoder_release_patch(&adev->ddp);
+        if (out->ac3_parser_init) {
+            aml_ac3_parser_reset(out->ac3_parser_handle);
+        }
     }
     /* clear the hdmitx channel config to default */
     if (out->multich == 6) {
@@ -1573,8 +1588,7 @@
         ret = 0;
         goto exit;
     }
-/*
-    ret = str_parms_get_str (parms, "A2dpSuspended", value, sizeof (value) );
+    /*ret = str_parms_get_str (parms, "A2dpSuspended", value, sizeof (value) );
     if (ret >= 0) {
         ret = a2dp_out_set_parameters(stream, kvpairs);
         goto exit;
@@ -1583,8 +1597,7 @@
     if (ret >= 0) {
         ret = a2dp_out_set_parameters(stream, kvpairs);
         goto exit;
-    }
-*/
+    }*/
 exit:
     str_parms_destroy (parms);
 
@@ -1716,14 +1729,23 @@
     return (frames * 1000) / out->config.rate + a2dp_delay;
 }
 
+static uint32_t out_get_alsa_latency (const struct audio_stream_out *stream)
+{
+    const struct aml_stream_out *out = (const struct aml_stream_out *) stream;
+    snd_pcm_sframes_t frames = out_get_alsa_latency_frames (stream);
+    return (frames * 1000) / out->config.rate;
+}
+
 #define FLOAT_ZERO 0.000001
 static int out_set_volume (struct audio_stream_out *stream, float left, float right)
 {
     struct aml_stream_out *out = (struct aml_stream_out *) stream;
     struct aml_audio_device *adev = out->dev;
     int ret = 0;
+    int is_dolby_audio = (out->hal_internal_format == AUDIO_FORMAT_E_AC3) || (out->hal_internal_format == AUDIO_FORMAT_AC3);
+    int is_dts_audio   = (out->hal_internal_format == AUDIO_FORMAT_DTS) || (out->hal_internal_format == AUDIO_FORMAT_DTS_HD);
     ALOGI("%s(), stream(%p), left:%f right:%f ", __func__, stream, left, right);
-    if (out->hal_internal_format == AUDIO_FORMAT_E_AC3) {
+    if (is_dolby_audio || is_dts_audio) {
         if (out->volume_l < FLOAT_ZERO && left > FLOAT_ZERO) {
             ALOGI("set offload mute: false");
             spdifenc_set_mute(false);
@@ -1739,7 +1761,7 @@
 
     // When MS12 input is PCM to OTT, ms12 fail to change volume.we will change volume at input side.
     // When MS12 input is DD/DDP, we adjust main DD/DDP input volume here
-    if ((eDolbyMS12Lib == adev->dolby_lib_type) && continous_mode(adev) && !audio_is_linear_pcm(out->hal_internal_format)) {
+    if ((eDolbyMS12Lib == adev->dolby_lib_type) && is_dolby_audio) {
         int iMS12DB = -96;
 
         if (out->volume_l != out->volume_r) {
@@ -1824,6 +1846,7 @@
     if (out->hw_sync_mode) {
         ALOGI("%s set AUDIO_PAUSE when tunnel mode\n",__func__);
         sysfs_set_sysfs_str (TSYNC_EVENT, "AUDIO_PAUSE");
+        out->tsync_status = TSYNC_STATUS_PAUSED;
     }
     pthread_mutex_unlock (&adev->lock);
     pthread_mutex_unlock (&out->lock);
@@ -1886,12 +1909,14 @@
         adev->hwsync_output = out;
         aml_hal_mixer_init(&adev->hal_mixer);
         sysfs_set_sysfs_str(TSYNC_EVENT, "AUDIO_RESUME");
+        out->tsync_status = TSYNC_STATUS_RUNNING;
     }
     out->pause_status = false;
 exit:
     if (out->hw_sync_mode) {
         ALOGI("%s set AUDIO_RESUME when tunnel mode\n",__func__);
         sysfs_set_sysfs_str (TSYNC_EVENT, "AUDIO_RESUME");
+        out->tsync_status = TSYNC_STATUS_RUNNING;
     }
     pthread_mutex_unlock (&adev->lock);
     pthread_mutex_unlock (&out->lock);
@@ -1921,6 +1946,7 @@
     */
     if (aml_out->hw_sync_mode) {
         sysfs_set_sysfs_str(TSYNC_EVENT, "AUDIO_PAUSE");
+        aml_out->tsync_status = TSYNC_STATUS_PAUSED;
     }
     if (eDolbyMS12Lib == aml_dev->dolby_lib_type) {
         if (aml_dev->continuous_audio_mode == 1) {
@@ -1957,6 +1983,7 @@
 
     if (aml_out->hw_sync_mode) {
         sysfs_set_sysfs_str(TSYNC_EVENT, "AUDIO_PAUSE");
+        aml_out->tsync_status = TSYNC_STATUS_PAUSED;
     }
 
 exit:
@@ -2019,6 +2046,7 @@
     aml_out->pause_status = false;
     if (aml_out->hw_sync_mode && !aml_dev->ms12.need_resume) {
         sysfs_set_sysfs_str(TSYNC_EVENT, "AUDIO_RESUME");
+        aml_out->tsync_status = TSYNC_STATUS_RUNNING;
     }
 
 exit:
@@ -2900,6 +2928,16 @@
         ALOGD("%s(): out %p, bytes %zu, hwsync:%d, last frame_write_sum %"PRIu64,
            __func__, out, bytes,
            out->hw_sync_mode, out->frame_write_sum);
+#if 0
+    FILE *fp1 = fopen ("/data/out_write_direct_passthrough.pcm", "a+");
+    if (fp1) {
+        int flen = fwrite ( (char *) buffer, 1, bytes, fp1);
+        //ALOGD("flen = %d---outlen=%d ", flen, out_frames * frame_size);
+        fclose (fp1);
+    } else {
+        ALOGD ("could not open file:/data/out_write_direct_passthrough.pcm");
+    }
+#endif
 
     if (adev->out_device != out->out_device) {
         ALOGD("%s:%p device:%x,%x", __func__, stream, out->out_device, adev->out_device);
@@ -2989,12 +3027,12 @@
             return hwsync_cost_bytes;
         }
         if (cur_pts != 0xffffffff && outsize > 0) {
-            int hwsync_hdmi_latency = aml_audio_get_hwsync_latency_offset();
+            int hwsync_hdmi_latency = aml_audio_get_hwsync_latency_offset(true);
             // if we got the frame body,which means we get a complete frame.
             //we take this frame pts as the first apts.
             //this can fix the seek discontinue,we got a fake frame,which maybe cached before the seek
             if (hw_sync->first_apts_flag == false) {
-                int latency = (out_get_latency(stream) + hwsync_hdmi_latency);
+                int latency = (out_get_alsa_latency(stream) + hwsync_hdmi_latency);
                 if ((latency > 0 && cur_pts >= (uint32_t)latency * 90)
                     /*&& out->last_frames_postion > 0*/) {
                     cur_pts -=  latency * 90;
@@ -3011,7 +3049,7 @@
                 uint32_t apts32;
                 uint pcr = 0;
                 uint apts_gap = 0;
-                int latency = (out_get_latency(stream) + hwsync_hdmi_latency) * 90;
+                int latency = (out_get_alsa_latency(stream) + hwsync_hdmi_latency) * 90;
                 // check PTS discontinue, which may happen when audio track switching
                 // discontinue means PTS calculated based on first_apts and frame_write_sum
                 // does not match the timestamp of next audio samples
@@ -3034,6 +3072,12 @@
                         __func__, apts32/90, pcr/90, latency/90,
                         (apts32 > pcr) ? (apts32 - pcr)/90 : (pcr - apts32)/90);
 
+                    /*during video stop, pcr has been reset by video
+                      we need ignore such pcr value*/
+                    if (pcr == 0) {
+                        ALOGI("pcr is reset by video");
+                        sync_status = CONTINUATION;
+                    }
                     // limit the gap handle to 0.5~5 s.
                     if (sync_status == ADJUSTMENT) {
                         // two cases: apts leading or pcr leading
@@ -3083,11 +3127,42 @@
             goto exit;
         }
     } else {
-        write_buf = (void *) buffer;
+        if (out->ac3_parser_init) {
+            struct ac3_parser_info ac3_info = { 0 };
+            int32_t parser_used_size = 0;
+            void *frame_buffer = NULL;
+            int frame_length = 0;
+            aml_ac3_parser_process(out->ac3_parser_handle, (char *)buffer + bytes_cost,
+                                    total_bytes - bytes_cost, &parser_used_size, &frame_buffer,
+                                    &frame_length, &ac3_info);
+            ALOGV("bytes cost=%d total=%d frame length=%d", bytes_cost, total_bytes, frame_length);
+            if (frame_length > 0) {
+                return_bytes = parser_used_size;
+                in_frames = frame_length / frame_size;
+                write_buf = frame_buffer;
+            } else {
+                /*go to exit, there will decide whether there is enough data*/
+                return_bytes = parser_used_size;
+                pthread_mutex_unlock (&adev->lock);
+                goto exit;
+            }
+        } else {
+            write_buf = (void *) buffer;
+        }
     }
     pthread_mutex_unlock (&adev->lock);
     out_frames = in_frames;
     buf = (void *) write_buf;
+    if (getprop_bool("vendor.media.hdmihal.outdump")) {
+        FILE *fp1 = fopen("/data/tmp/hal_audio_out.pcm", "a+");
+        if (fp1) {
+            int flen = fwrite ( (char *) buffer, 1, bytes, fp1);
+            //ALOGD("flen = %d---outlen=%d ", flen, out_frames * frame_size);
+            fclose (fp1);
+        } else {
+            ALOGD("could not open file:/data/tmp/hal_audio_out.pcm");
+        }
+    }
 
     if (out->need_convert) {
         int ret = -1;
@@ -3113,6 +3188,9 @@
                     memset(ddp_dec->outbuf_raw, 0, ddp_dec->outlen_raw);
                 }
                 ALOGV("dd raw=%d", ddp_dec->outlen_raw);
+                if (out->offload_mute == true) {
+                    memset(ddp_dec->outbuf_raw, 0, ddp_dec->outlen_raw);
+                }
                 ret = pcm_write (out->pcm, ddp_dec->outbuf_raw, ddp_dec->outlen_raw);
             }
             if (ret == 0) {
@@ -3130,6 +3208,7 @@
             size_t output_buffer_bytes = 0;
 
             if (out->spdifenc_init) {
+                aml_spdif_encoder_mute(out->spdifenc_handle, out->offload_mute);
                 ret = aml_spdif_encoder_process(out->spdifenc_handle, buf, out_frames * frame_size, &output_buffer, &output_buffer_bytes);
                 if (ret != 0) {
                     ALOGE("%s: spdif encoder process error", __func__);
@@ -3138,6 +3217,9 @@
             } else {
                 output_buffer = buf;
                 output_buffer_bytes = out_frames * frame_size;
+                if (out->offload_mute == true) {
+                    memset(output_buffer, 0, output_buffer_bytes);
+                }
             }
             ALOGV("spdifb output size=%d", output_buffer_bytes);
             if (output_buffer_bytes) {
@@ -3146,10 +3228,11 @@
                 if (status.state == PCM_STATE_SETUP ||
                     status.state == PCM_STATE_PREPARED ||
                     status.state == PCM_STATE_XRUN) {
-                    ALOGI("mute the first raw data");
+                    ALOGI("spdif b mute the first raw data");
                     memset(output_buffer, 0, output_buffer_bytes);
                 }
                 ret = pcm_write (out->pcm2, output_buffer, output_buffer_bytes);
+
             }
         }
 
@@ -3182,16 +3265,49 @@
         //for 5.1/7.1 LPCM direct output,we assume only use left channel volume
         if (!codec_type_is_raw_data(out->codec_type)
                 && (out->multich > 2 || out->hal_internal_format != AUDIO_FORMAT_PCM_16_BIT)) {
+            //do audio format and data conversion here
+            int input_frames = out_frames;
+            write_buf = convert_audio_sample_for_output (input_frames,
+                    out->hal_internal_format, out->multich, buf, &write_size);
             //volume apply here,TODO need apply that inside convert_audio_sample_for_output function.
-            apply_volume(out->volume_l, write_buf, audio_bytes_per_sample(out->hal_format), bytes);
+            if (out->multich == 2) {
+                short *sample = (short*) write_buf;
+                int l, r;
+                int kk;
+                for (kk = 0; kk <  input_frames; kk++) {
+                    l = out->volume_l * sample[kk * 2];
+                    sample[kk * 2] = CLIP (l);
+                    r = out->volume_r * sample[kk * 2 + 1];
+                    sample[kk * 2 + 1] = CLIP (r);
+                }
+            } else {
+                int *sample = (int*) write_buf;
+                int kk;
+                for (kk = 0; kk <  write_size / 4; kk++) {
+                    sample[kk] = out->volume_l * sample[kk];
+                }
+            }
 
             if (write_buf) {
+                if (getprop_bool ("vendor.media.hdmihal.outdump") ) {
+                    FILE *fp1 = fopen ("/data/tmp/hdmi_audio_out8.pcm", "a+");
+                    if (fp1) {
+                        int flen = fwrite ( (char *) buffer, 1, out_frames * frame_size, fp1);
+                        ALOGD ("flen = %d---outlen=%zu ", flen, out_frames * frame_size);
+                        fclose (fp1);
+                    } else {
+                        ALOGD ("could not open file:/data/hdmi_audio_out.pcm");
+                    }
+                }
                 ret = pcm_write (out->pcm, write_buf, write_size);
                 if (ret == 0) {
                     out->frame_write_sum += out_frames;
                 } else {
                     ALOGI ("pcm_get_error(out->pcm):%s",pcm_get_error (out->pcm) );
                 }
+                if (write_buf) {
+                    free (write_buf);
+                }
             }
         } else {
             //2 channel LPCM or raw data pass through
@@ -3206,7 +3322,16 @@
                     sample[kk * 2 + 1] = CLIP (r);
                 }
             }
-
+#if 0
+            FILE *fp1 = fopen ("/data/pcm_write_passthrough.pcm", "a+");
+            if (fp1) {
+                int flen = fwrite ( (char *) buf, 1, out_frames * frame_size, fp1);
+                //ALOGD("flen = %d---outlen=%d ", flen, out_frames * frame_size);
+                fclose (fp1);
+            } else {
+                ALOGD ("could not open file:/data/pcm_write_passthrough.pcm");
+            }
+#endif
             if (out->offload_mute) {
                 memset(buf, 0, out_frames * frame_size);
             }
@@ -3291,7 +3416,6 @@
         if (direct_continous((struct audio_stream_out *)stream)) {
             *dsp_frames = adev->ms12.last_frames_postion;
         }
-
         /*when it is ddp 2ch/heaac we need use different latency control*/
         if (audio_is_linear_pcm(out->hal_internal_format)) {
             b_raw = 0;
@@ -3306,7 +3430,7 @@
             frame_latency -= aml_audio_get_ms12_atmos_latency_offset(tunnel) * 48;
         }
 #endif
-        if ((!adev->is_ms12sys_lat || adev->compensate_video_enable) && audio_is_linear_pcm(out->hal_internal_format))
+        if ((!adev->is_netflix || adev->compensate_video_enable) && audio_is_linear_pcm(out->hal_internal_format))
             frame_latency = 0;
 
         if (*dsp_frames >= (uint64_t)abs(frame_latency)) {
@@ -3326,7 +3450,6 @@
             *dsp_frames += drift_frames;
 
         }
-
     }
 
     if (adev->active_outport == OUTPORT_HDMI_ARC && !adev->continuous_audio_mode) {
@@ -3456,19 +3579,23 @@
             *timestamp = adev->ms12.timestamp;
         }
 
-        /*when it is ddp 2ch/heaac we need use different latency control*/
-        if (audio_is_linear_pcm(out->hal_internal_format)) {
-            b_raw = 0;
-        }else {
-            b_raw = 1;
-        }
-        frame_latency = aml_audio_get_ms12_latency_offset(b_raw) * 48;
+        /*this tunning is only for netflix*/
+        if (adev->is_netflix) {
+            /*when it is ddp 2ch/heaac we need use different latency control*/
+            if (audio_is_linear_pcm(out->hal_internal_format)) {
+                b_raw = 0;
+            }else {
+                b_raw = 1;
+            }
+            frame_latency = aml_audio_get_ms12_latency_offset(b_raw) * 48;
 
-        if ((adev->ms12.is_dolby_atmos && adev->ms12_main1_dolby_dummy == false) || adev->atoms_lock_flag) {
-            int tunnel = 0;
-            frame_latency -= aml_audio_get_ms12_atmos_latency_offset(tunnel) * 48;
+            if ((adev->ms12.is_dolby_atmos && adev->ms12_main1_dolby_dummy == false) || adev->atoms_lock_flag) {
+                int tunnel = 0;
+                frame_latency -= aml_audio_get_ms12_atmos_latency_offset(tunnel) * 48;
+            }
         }
-        if ((!adev->is_ms12sys_lat || adev->compensate_video_enable) && audio_is_linear_pcm(out->hal_internal_format))
+
+        if ((!adev->is_netflix || adev->compensate_video_enable) && audio_is_linear_pcm(out->hal_internal_format))
             frame_latency = 0;
 
         if (*frames >= (uint64_t)abs(frame_latency)) {
@@ -3492,6 +3619,22 @@
     }
     if (adev->debug_flag) {
         ALOGI("out_get_presentation_position out %p %"PRIu64", sec = %ld, nanosec = %ld\n", out, *frames, timestamp->tv_sec, timestamp->tv_nsec);
+        int64_t  frame_diff_ms =  (*frames - out->last_frame_reported)/48;
+        int64_t  system_time_ms = 0;
+        if (timestamp->tv_nsec < out->last_timestamp_reported.tv_nsec) {
+            system_time_ms = (timestamp->tv_nsec + 1000000000 - out->last_timestamp_reported.tv_nsec)/1000000;
+        }
+        else
+            system_time_ms = (timestamp->tv_nsec - out->last_timestamp_reported.tv_nsec)/1000000;
+        int64_t jitter_diff = llabs(frame_diff_ms - system_time_ms);
+        if  (jitter_diff > JITTER_DURATION_MS) {
+            ALOGI("%s jitter out last pos info: %p %"PRIu64", sec = %ld, nanosec = %ld\n",__func__,out, out->last_frame_reported,
+                out->last_timestamp_reported.tv_sec, out->last_timestamp_reported.tv_nsec);
+            ALOGI("%s jitter  system time diff %"PRIu64" ms, position diff %"PRIu64" ms, jitter %"PRIu64" ms \n",
+                __func__,system_time_ms,frame_diff_ms,jitter_diff);
+        }
+        out->last_frame_reported = *frames;
+        out->last_timestamp_reported = *timestamp;
     }
     return 0;
 }
@@ -4399,6 +4542,15 @@
         ret = -EINVAL;
         goto err;
     }
+    out->hal_ch   = audio_channel_count_from_out_mask(out->hal_channel_mask);
+    out->hal_frame_size = audio_bytes_per_frame(out->hal_ch, out->hal_internal_format);
+    if (out->hal_ch == 0) {
+        out->hal_ch = 2;
+    }
+    if (out->hal_frame_size == 0) {
+        out->hal_frame_size = 1;
+    }
+
     out->stream.common.get_sample_rate = out_get_sample_rate;
     out->stream.common.set_sample_rate = out_set_sample_rate;
     out->stream.common.get_buffer_size = out_get_buffer_size;
@@ -4581,6 +4733,12 @@
         out->spdifenc_init = false;
     }
 
+    if (out->ac3_parser_init) {
+        aml_ac3_parser_close(out->ac3_parser_handle);
+        out->ac3_parser_handle = NULL;
+        out->ac3_parser_init = false;
+    }
+
     if (out->flags & AUDIO_OUTPUT_FLAG_MMAP_NOIRQ) {
         outMmapDeInit(out);
     }
@@ -4858,7 +5016,7 @@
         if ((val & AUDIO_DEVICE_OUT_HDMI_ARC) || (val & AUDIO_DEVICE_OUT_HDMI)) {
             adev->bHDMIConnected = 0;
             adev->bHDMIConnected_update = 1;
-            ALOGI("bHDMIConnected: %d\n", val);
+            ALOGI("disconnect bHDMIConnected: %d\n", val);
             if (adev->patch_src == SRC_DTV) {
                 ALOGI("disconnect set reset_dtv_audio 1\n");
                 adev->reset_dtv_audio = 1;
@@ -4866,7 +5024,7 @@
         } else if (val & AUDIO_DEVICE_OUT_ALL_A2DP) {
             adev->a2dp_updated = 1;
             adev->out_device &= (~val);
-			a2dp_out_close(dev);
+            a2dp_out_close(dev);
             ALOGI("adev_set_parameters a2dp disconnect: %x, device=%x\n", val, adev->out_device);
         }
         goto exit;
@@ -4879,7 +5037,8 @@
             goto exit;
         if ((val & AUDIO_DEVICE_OUT_HDMI_ARC) || (val & AUDIO_DEVICE_OUT_HDMI)) {
             adev->bHDMIConnected = 1;
-            ALOGI("%s,bHDMIConnected: %d\n", __FUNCTION__, val);
+            adev->bHDMIConnected_update = 1;
+            ALOGI("%s,connect bHDMIConnected: %d\n", __FUNCTION__, val);
             if (adev->patch_src == SRC_DTV) {
                 ALOGI("connect set reset_dtv_audio 1\n");
                 adev->reset_dtv_audio = 1;
@@ -4887,7 +5046,7 @@
         } else if (val & AUDIO_DEVICE_OUT_ALL_A2DP) {
             adev->a2dp_updated = 1;
             adev->out_device |= val;
-			a2dp_out_open(dev);
+            a2dp_out_open(dev);
             ALOGI("adev_set_parameters a2dp connect: %x, device=%x\n", val, adev->out_device);
         }
         goto exit;
@@ -5217,7 +5376,9 @@
         if (ret >= 0) {
             pthread_mutex_lock(&adev->lock);
             pthread_mutex_lock(&ms12->lock);
-            dtv_assoc_audio_cache(-1);
+            if (val == 0) {
+                dtv_assoc_audio_cache(-1);
+            }
             adev->associate_audio_mixing_enable = val;
             ALOGI("associate_audio_mixing_enable set to %d\n", adev->associate_audio_mixing_enable);
             dolby_ms12_set_asscociated_audio_mixing(adev->associate_audio_mixing_enable);
@@ -5262,7 +5423,7 @@
                 ALOGI("exit netflix, set atmos lock as 0");
             }
             ALOGI("%s ignore the continuous_audio_mode!\n", __func__ );
-            adev->is_ms12sys_lat = val;
+            adev->is_netflix = val;
             goto exit;
             ALOGI("%s continuous_audio_mode set to %d\n", __func__ , val);
             char buf[PROPERTY_VALUE_MAX];
@@ -5460,6 +5621,16 @@
         ALOGI("DTV sound mode %d ",mode );
         adev->audio_patch->mode = mode;
     }
+    ret = str_parms_get_str(parms, "sound_track", value, sizeof(value));
+    if (ret > 0) {
+        int mode = atoi(value);
+        if (adev->audio_patch != NULL) {
+            ALOGI("%s()the audio patch is not NULL \n", __func__);
+            goto exit;
+        }
+        ALOGI("video player sound_track mode %d ",mode );
+        adev->sound_track_mode = mode;
+    }
     ret = str_parms_get_str(parms, "fmt", value, sizeof(value));
     if (ret > 0) {
         unsigned int audio_fmt = (unsigned int)atoi(value); // zz
@@ -6147,15 +6318,16 @@
     return;
 }
 
-const char *audio_port_role[] = {"AUDIO_PORT_ROLE_NONE", "AUDIO_PORT_ROLE_SOURCE", "AUDIO_PORT_ROLE_SINK"};
-const char *audio_port_type[] = {"AUDIO_PORT_TYPE_NONE", "AUDIO_PORT_TYPE_DEVICE", "AUDIO_PORT_TYPE_MIX", "AUDIO_PORT_TYPE_SESSION"};
 static void dump_audio_port_config (const struct audio_port_config *port_config)
 {
     if (port_config == NULL)
         return;
 
     ALOGI ("  -%s port_config(%p)", __FUNCTION__, port_config);
-    ALOGI ("\t-id(%d), role(%s), type(%s)", port_config->id, audio_port_role[port_config->role], audio_port_type[port_config->type]);
+    ALOGI ("\t-id(%d), role(%s), type(%s)",
+        port_config->id,
+        audio_port_role_to_str(port_config->role),
+        audio_port_type_to_str(port_config->type));
     ALOGV ("\t-config_mask(%#x)", port_config->config_mask);
     ALOGI ("\t-sample_rate(%d), channel_mask(%#x), format(%#x)", port_config->sample_rate,
            port_config->channel_mask, port_config->format);
@@ -6223,6 +6395,18 @@
         }
     }
     aml_out->status = STREAM_STANDBY;
+    aml_out->standby= 1;
+    /*
+     *belive that audio is discontinuous in the dtv
+     *ignore the val of adev->continuous_audio_mode
+     */
+    if (adev->patch_src == SRC_DTV && adev->audio_patch != NULL) {
+        int dtv_format = adev->audio_patch->dtv_aformat;
+        if ((IS_DOBLBY_FORMAT(dtv_format) || IS_DTS_FORMAT(dtv_format)) &&
+             !aml_out->dual_output_flag && (AUDIO_FORMAT_PCM_16_BIT != get_output_format(out))) {
+            aml_audio_set_spdif_format(PORT_SPDIF, AML_STEREO_PCM, aml_out);
+        }
+    }
 
     if (adev->continuous_audio_mode == 0) {
         // release buffers
@@ -6285,6 +6469,7 @@
                         adev->need_remove_conti_mode = false;
                         adev->continuous_audio_mode = 0;
                     }
+
                     pthread_mutex_lock(&adev->ms12.lock);
                     /*after standby we should clean ms12 position*/
                     adev->ms12.last_frames_postion = 0;
@@ -6329,6 +6514,17 @@
         aml_out->normal_pcm_mixing_config = false;
     }
     aml_out->pause_status = false;//clear pause status
+
+    if (aml_out->hw_sync_mode && aml_out->tsync_status != TSYNC_STATUS_STOP) {
+        ALOGI("%s set AUDIO_PAUSE\n",__func__);
+        sysfs_set_sysfs_str (TSYNC_EVENT, "AUDIO_PAUSE");
+        aml_out->tsync_status = TSYNC_STATUS_PAUSED;
+
+        ALOGI("%s set AUDIO_STOP\n",__func__);
+        sysfs_set_sysfs_str (TSYNC_EVENT, "AUDIO_STOP");
+        aml_out->tsync_status = TSYNC_STATUS_STOP;
+    }
+
     return 0;
 }
 
@@ -6340,10 +6536,10 @@
     ALOGD("%s: enter", __func__);
     if (continous_mode(aml_out->dev)
         && (aml_out->flags & AUDIO_OUTPUT_FLAG_HW_AV_SYNC)) {
-        //1.audio easing duration is 64ms,
-        //2.one loop for schedule_run cost about 64ms(contains the hardware costing),
+        //1.audio easing duration is 32ms,
+        //2.one loop for schedule_run cost about 32ms(contains the hardware costing),
         //3.if [pause, flush] too short, means it need more time to do audio easing
-        //so, the delay time for 64ms(pause is completed after audio easing is done) is enough.
+        //so, the delay time for 32ms(pause is completed after audio easing is done) is enough.
         aml_audio_sleep(64000);
     }
     pthread_mutex_lock (&aml_out->dev->lock);
@@ -6779,7 +6975,11 @@
     uint64_t total_frame = 0;
 
     /* raw data need packet to IEC61937 format by spdif encoder */
-    if ((output_format == AUDIO_FORMAT_AC3) || (output_format == AUDIO_FORMAT_E_AC3)) {
+    if (output_format == AUDIO_FORMAT_IEC61937) {
+        //ALOGI("IEC61937 Format");
+        *output_buffer = (void *) buffer;
+        *output_buffer_bytes = bytes;
+    } else if ((output_format == AUDIO_FORMAT_AC3) || (output_format == AUDIO_FORMAT_E_AC3)) {
         //ALOGI("%s, aml_out->hal_format %x , is_iec61937_format = %d, \n", __func__, aml_out->hal_format,is_iec61937_format(stream));
         if ((is_iec61937_format(stream) == true) ||
             (adev->dolby_lib_type == eDolbyDcvLib)) {
@@ -6984,6 +7184,8 @@
                 source_gain = 1.0;
             if (adev->patch_src == SRC_DTV && adev->audio_patch != NULL) {
                 aml_audio_switch_output_mode((int16_t *)effect_tmp_buf, bytes, adev->audio_patch->mode);
+            } else if ( adev->audio_patch == NULL) {
+               aml_audio_switch_output_mode((int16_t *)effect_tmp_buf, bytes, adev->sound_track_mode);
             }
             /* apply volume for spk/hp, SPDIF/HDMI keep the max volume */
             gain_speaker *= (adev->sink_gain[OUTPORT_SPEAKER] * source_gain);
@@ -7029,6 +7231,16 @@
             else
                 gain_speaker = adev->sink_gain[OUTPORT_SPEAKER];
 
+            /*
+            for dolby audio with ms12 enabled,the gain will apply to
+            ms12 main audio, there is no need to apply any more.
+            */
+            int is_dolby_audio = (aml_out->hal_internal_format == AUDIO_FORMAT_E_AC3) \
+                                 || (aml_out->hal_internal_format == AUDIO_FORMAT_AC3);
+            if ((eDolbyMS12Lib == adev->dolby_lib_type) && is_dolby_audio) {
+                gain_speaker = 1.0;
+            }
+
             if (adev->patch_src == SRC_DTV && adev->audio_patch != NULL) {
                 aml_audio_switch_output_mode((int16_t *)buffer, bytes, adev->audio_patch->mode);
             }
@@ -7100,6 +7312,7 @@
     uint32_t latency_frames = 0;
     uint64_t total_frame = 0;
     uint64_t write_frames = 0;
+    uint64_t  sys_total_cost = 0;
     int  adjust_ms = 0;
     int  alsa_port = -1;
 
@@ -7112,10 +7325,11 @@
             adev->audio_patch->avsync_callback(adev->audio_patch,aml_out);
     }
     pthread_mutex_lock(&adev->alsa_pcm_lock);
+    aml_out->alsa_output_format = output_format;
     if (aml_out->status != STREAM_HW_WRITING) {
         ALOGI("%s, aml_out %p alsa open output_format %#x\n", __func__, aml_out, output_format);
         if (eDolbyDcvLib == adev->dolby_lib_type) {
-            if (!aml_out->dual_output_flag) {
+            if (!aml_out->dual_output_flag && !aml_out->dual_spdif) {
                 aml_audio_set_spdif_format(PORT_SPDIF, halformat_convert_to_spdif(output_format), aml_out);
                 aml_audio_select_spdif_to_hdmi(AML_SPDIF_A_TO_HDMITX);
             }
@@ -7178,7 +7392,24 @@
                 if (is_bypass_dolbyms12(stream))
                     aml_audio_hwsync_audio_process(aml_out->hwsync, aml_out->hwsync->payload_offset, &adjust_ms);
                 else {
-                    aml_audio_hwsync_audio_process(aml_out->hwsync, dolby_ms12_get_consumed_payload(), &adjust_ms);
+                    if (!audio_is_linear_pcm(aml_out->hal_internal_format)) {
+                        /*if udc decode doens't generate any data, we should not use the consume offset to get pts*/
+                        ALOGV("udc generate pcm =%lld", dolby_ms12_get_n_bytes_pcmout_of_udc());
+                        if (dolby_ms12_get_n_bytes_pcmout_of_udc()) {
+                            aml_audio_hwsync_audio_process(aml_out->hwsync, dolby_ms12_get_consumed_payload(), &adjust_ms);
+                        }
+                    } else {
+                        /* because the pcm consumed playload offset is at the end of consume buffer,
+                         * we need the beginning position and ms12 always
+                         * output 1536 frame every time
+                         */
+                        uint64_t consume_payload = dolby_ms12_get_consumed_payload();
+                        uint32_t ms12_frame_bytes = 1536 * aml_out->hal_frame_size;
+                        if (consume_payload >= ms12_frame_bytes) {
+                            consume_payload -= ms12_frame_bytes;
+                            aml_audio_hwsync_audio_process(aml_out->hwsync, consume_payload, &adjust_ms);
+                        }
+                    }
                 }
             } else {
                 ALOGV("%s,aml_out->hwsync->aout == NULL",__FUNCTION__);
@@ -7406,7 +7637,7 @@
         if (total_frame >= latency_frames) {
             aml_out->last_frames_postion = total_frame - latency_frames;
         } else {
-            aml_out->last_frames_postion = total_frame;
+            aml_out->last_frames_postion = 0;
         }
         aml_out->position_update = 1;
         //ALOGI("position =%lld time sec = %ld, nanosec = %ld", aml_out->last_frames_postion, aml_out->lasttimestamp.tv_sec , aml_out->lasttimestamp.tv_nsec);
@@ -7414,23 +7645,24 @@
     if (eDolbyMS12Lib == adev->dolby_lib_type) {
         if (continous_mode(adev)) {
             struct timespec ts;
-            adev->ms12.last_frames_postion = aml_out->last_frames_postion;
             clock_gettime(CLOCK_MONOTONIC, &ts);
             adev->ms12.timestamp.tv_sec = ts.tv_sec;
             adev->ms12.timestamp.tv_nsec = ts.tv_nsec;
+            adev->ms12.last_frames_postion = aml_out->last_frames_postion;
 
         }
+        /* check sys audio postion */
     }
-
     if (adev->debug_flag) {
         ALOGI("%s() stream(%p) pcm handle %p format input %#x output %#x 61937 frame %d",
               __func__, stream, aml_out->pcm, aml_out->hal_internal_format, output_format, is_iec61937_format(stream));
 
         if (eDolbyMS12Lib == adev->dolby_lib_type) {
             //ms12 internal buffer avail(main/associate/system)
-            if (adev->ms12.dolby_ms12_enable == true)
+            if (adev->ms12.dolby_ms12_enable == true) {
                 ALOGI("%s MS12 buffer avail main %d associate %d system %d\n",
                       __FUNCTION__, dolby_ms12_get_main_buffer_avail(NULL), dolby_ms12_get_associate_buffer_avail(), dolby_ms12_get_system_buffer_avail(NULL));
+            }
         }
 
         if ((aml_out->hal_internal_format == AUDIO_FORMAT_AC3) || (aml_out->hal_internal_format == AUDIO_FORMAT_E_AC3)) {
@@ -7544,8 +7776,9 @@
                 dolby_ms12_set_main_dummy(0, main1_dummy);
                 dolby_ms12_set_main_dummy(1, !ott_input);
             }
-            if (adev->ms12_out != NULL)
+            if (adev->ms12_out != NULL) {
                 aml_audio_hwsync_init(adev->ms12_out->hwsync, adev->ms12_out);
+            }
 
             adev->mix_init_flag = true;
             ALOGI("%s() get_the_dolby_ms12_prepared %s, ott_enable = %d, main1_dummy = %d", __FUNCTION__, (ret == 0) ? "succuss" : "fail", ott_input, main1_dummy);
@@ -7703,10 +7936,11 @@
             //STB case
             if (!adev->is_TV) {
                 aml_out->dual_output_flag = 0;
+                adev->dtslib_bypass_enable = 1;
             } else {
                 aml_out->dual_output_flag = true ;
+                adev->dtslib_bypass_enable = 0;
             }
-            adev->dtslib_bypass_enable = 0;
             adev->optical_format = AUDIO_FORMAT_AC3;
             break;
         case AUTO:
@@ -8049,6 +8283,7 @@
                 pthread_mutex_unlock(&ms12->lock);
                 if (aml_out->hw_sync_mode) {
                     sysfs_set_sysfs_str(TSYNC_EVENT, "AUDIO_RESUME");
+                    aml_out->tsync_status = TSYNC_STATUS_RUNNING;
                     adev->ms12.need_resync = 1;
                 }
                 adev->ms12.need_resume = 0;
@@ -8273,6 +8508,21 @@
                     hw_write (stream, output_buffer, output_buffer_bytes, output_format);
             }
             else {
+                /*not continuous mode, we use sink gain control the volume*/
+                if (!continous_mode(adev)) {
+                    /*for pcm output, we will control it in hal_data_process*/
+                    if (!adev->is_TV && (adev->audio_patching)) {
+                        float out_gain = 1.0f;
+                        out_gain = adev->sink_gain[adev->active_outport];
+                        if (!audio_is_linear_pcm(aml_out->hal_internal_format)) {
+                            dolby_ms12_set_main_volume(out_gain);
+                        } else {
+                            //for stb,no chance to here
+                            //apply_volume(out_gain, write_buf, sizeof(int16_t), write_bytes);
+                        }
+                    }
+                }
+
 re_write:
                 if (adev->debug_flag) {
                     ALOGI("%s dolby_ms12_main_process before write_bytes %zu!\n", __func__, write_bytes);
@@ -8622,6 +8872,12 @@
                     ALOGI("%s mute the mixer voice(system/alexa)\n", __FUNCTION__);
                 }
             }
+
+            /*for ms12 system input, we need do track switch before enter ms12*/
+            {
+                aml_audio_switch_output_mode((int16_t *)buffer, bytes, adev->sound_track_mode);
+            }
+
             int count = 0;
             while (bytes_remaining && adev->ms12.dolby_ms12_enable && retry < 10) {
                 size_t used_size = 0;
@@ -8675,8 +8931,8 @@
             aml_out->last_frames_postion -= alsa_latency_frame;
         }
         if (adev->debug_flag) {
-            ALOGI("%s stream audio presentation %"PRIu64" latency_frame %d.ms12 system latency_frame %d", __func__,
-                  aml_out->last_frames_postion, alsa_latency_frame, system_latency);
+            ALOGI("%s stream audio presentation %"PRIu64" latency_frame %d.ms12 system latency_frame %d,total frame=%lld %lld ms",
+                  __func__,aml_out->last_frames_postion, alsa_latency_frame, system_latency,aml_out->frame_write_sum, aml_out->frame_write_sum/48);
         }
     } else {
         aml_out->last_frames_postion = aml_out->frame_write_sum;
@@ -8727,7 +8983,7 @@
        ALOGW("[%s:%d] is_bypass_dolbyms12, not support app write", __func__, __LINE__);
        return -1;
    }
-
+   
    while (bytes_remaining && adev->ms12.dolby_ms12_enable && retry > 0) {
        size_t used_size = 0;
        ret = dolby_ms12_app_process(stream, (char *)buffer + bytes_written, bytes_remaining, &used_size);
@@ -8740,6 +8996,7 @@
            aml_audio_sleep(1000);
        }
    }
+ 
    if (retry <= 10) {
        ALOGE("[%s:%d] write retry=%d ", __func__, __LINE__, retry);
    }
@@ -8751,6 +9008,7 @@
    return bytes;
 }
 #endif
+
 ssize_t process_buffer_write(struct audio_stream_out *stream,
                             const void *buffer,
                             size_t bytes)
@@ -8858,9 +9116,11 @@
              */
             if (aml_out->is_normal_pcm) {
                 aml_out->write = mixer_aux_buffer_write;
+                aml_out->write_func = MIXER_AUX_BUFFER_WRITE;
                 ALOGI("%s(),1 mixer_aux_buffer_write !", __FUNCTION__);
             } else {
                 aml_out->write = mixer_main_buffer_write;
+                aml_out->write_func = MIXER_MAIN_BUFFER_WRITE;
                 ALOGI("%s(),1 mixer_main_buffer_write !", __FUNCTION__);
             }
         } else {
@@ -8879,13 +9139,16 @@
          */
         if (aml_out->is_normal_pcm) {
             aml_out->write = mixer_aux_buffer_write;
+            aml_out->write_func = MIXER_AUX_BUFFER_WRITE;
+
             //ALOGE("%s(),2 mixer_aux_buffer_write !", __FUNCTION__);
             //FIXEME if need config ms12 here if neeeded.
         } else if (aml_out->flags & AUDIO_OUTPUT_FLAG_MMAP_NOIRQ) {
             //aml_out->write = mixer_app_buffer_write;
-            ALOGW("[%s:%d] Temporarily not supported ms12 mixer_app_buffer_write input!", __func__, __LINE__);
+            //ALOGI("[%s:%d], mixer_app_buffer_write !", __func__, __LINE__);
         } else {
             aml_out->write = mixer_main_buffer_write;
+            aml_out->write_func = MIXER_MAIN_BUFFER_WRITE;
             //ALOGE("%s(),2 mixer_main_buffer_write !", __FUNCTION__);
         }
     }
@@ -8940,6 +9203,9 @@
      */
     pthread_mutex_lock(&adev->lock);
     ret = usecase_change_validate_l(aml_out, false);
+    if (aml_out->is_normal_pcm) {
+        adev->sys_audio_frame_written = aml_out->frame_write_sum;
+    }
     if (ret < 0) {
         ALOGE("%s() failed", __func__);
         pthread_mutex_unlock(&adev->lock);
@@ -8973,14 +9239,9 @@
     struct aml_audio_device *adev = (struct aml_audio_device *)dev;
     struct aml_stream_out *aml_out = NULL;
     stream_usecase_t usecase = STREAM_PCM_NORMAL;
-    bool tv_src_stream = false;
     int ret;
 
     ALOGD("%s: enter", __func__);
-    if (address && !strncmp(address, "AML_TV_SOURCE", 13)) {
-        ALOGI("%s(): aml TV source stream", __func__);
-        tv_src_stream = true;
-    }
     ret = adev_open_output_stream(dev,
                                     0,
                                     devices,
@@ -8994,6 +9255,10 @@
 
     aml_out = (struct aml_stream_out *)(*stream_out);
     /* only pcm mode use new write method */
+    if (address && !strncmp(address, "AML_TV_SOURCE", 13)) {
+        ALOGI("%s(): aml TV source stream", __func__);
+        aml_out->tv_src_stream = true;
+    }
 
     get_sink_format(&aml_out->stream);
     aml_out->card = alsa_device_get_card_index();
@@ -9014,8 +9279,7 @@
             aml_out->usecase == STREAM_PCM_HWSYNC ||
             aml_out->usecase == STREAM_PCM_MMAP) {
             /*for 96000, we need bypass submix, this is for DTS certification*/
-            if (config->sample_rate == 96000 || config->sample_rate == 88200 ||
-                    audio_channel_count_from_out_mask(config->channel_mask) > 2) {
+            if (config->sample_rate == 96000 || config->sample_rate == 88200) {
                 aml_out->bypass_submix = true;
                 aml_out->stream.write = out_write_direct;
                 aml_out->stream.common.standby = out_standby_direct;
@@ -9093,9 +9357,14 @@
             }
         }
     }
-    if (aml_out->hw_sync_mode) {
+    if (aml_out->hw_sync_mode && aml_out->tsync_status != TSYNC_STATUS_STOP) {
+        ALOGI("%s set AUDIO_PAUSE when close stream\n",__func__);
+        sysfs_set_sysfs_str (TSYNC_EVENT, "AUDIO_PAUSE");
+        aml_out->tsync_status = TSYNC_STATUS_PAUSED;
+
         ALOGI("%s set AUDIO_STOP when close stream\n",__func__);
         sysfs_set_sysfs_str (TSYNC_EVENT, "AUDIO_STOP");
+        aml_out->tsync_status = TSYNC_STATUS_STOP;
     }
     adev_close_output_stream(dev, stream);
     //adev->dual_decoder_support = false;
@@ -9951,6 +10220,10 @@
             aml_dev->out_device |= sink_config[i].ext.device.type;
         }
 
+        if (!aml_dev->is_TV) {
+            aml_dev->sink_gain[outport] = 1.0;
+        }
+
         ALOGI("%s: mix->device patch: outport(%d)", __func__, outport);
         return 0;
     }
@@ -10033,7 +10306,6 @@
             ret = create_dtv_patch(dev, AUDIO_DEVICE_IN_TV_TUNER,AUDIO_DEVICE_OUT_SPEAKER);
             if (ret == 0) {
                 aml_dev->audio_patching = 1;
-                dtv_patch_add_cmd(AUDIO_DTV_PATCH_CMD_START);/// zzz,this command should not be sent here
             }
         }
         ALOGI("%s: device->mix patch: inport(%s)", __func__, input_ports[inport]);
@@ -10195,7 +10467,6 @@
                                     AUDIO_DEVICE_OUT_SPEAKER);
              if (ret == 0) {
                 aml_dev->audio_patching = 1;
-                dtv_patch_add_cmd(AUDIO_DTV_PATCH_CMD_START);/// zzz,this command should not be sent here
              }
             ALOGI("%s, now end create dtv patch the audio_patching is %d ", __func__, aml_dev->audio_patching);
 #endif
@@ -10292,7 +10563,8 @@
             release_parser(aml_dev);
         }
 #ifdef ENABLE_DTV_PATCH
-        if (aml_dev->patch_src == SRC_DTV) {
+        if (aml_dev->patch_src == SRC_DTV &&
+                patch->sources[0].ext.device.type == AUDIO_DEVICE_IN_TV_TUNER) {
             ALOGI("patch src == DTV now line %d \n", __LINE__);
             release_dtv_patch(aml_dev);
             aml_dev->audio_patching = 0;
@@ -10425,6 +10697,7 @@
     }
     return 0;
 }
+
 static int adev_dump(const audio_hw_device_t *device, int fd)
 {
     struct aml_audio_device* aml_dev = (struct aml_audio_device*)device;
@@ -10459,6 +10732,22 @@
         subMixingDump(fd, aml_dev);
     }
 
+    dprintf(fd, "\n[AML_HAL] usecase_masks: %#x\n", aml_dev->usecase_masks);
+    dprintf(fd, "\nAML stream outs:\n");
+    for (i = 0; i < STREAM_USECASE_MAX ; i++) {
+        aml_out = aml_dev->active_outputs[i];
+        if (aml_out) {
+            dprintf(fd, "  out: %d, pointer: %p\n", i, aml_out);
+            aml_stream_out_dump(aml_out, fd);
+        }
+    }
+
+    if (aml_dev->useSubMix) {
+        subMixingDump(fd, aml_dev);
+    }
+
+    aml_audio_patches_dump(aml_dev, fd);
+
     return 0;
 }
 
@@ -10960,7 +11249,7 @@
         memset(&adev->ddp, 0, sizeof(struct dolby_ddp_dec));
         adev->dcvlib_bypass_enable = 1;
     }
-
+    adev->sound_track_mode = 0;
 #if ENABLE_NANO_NEW_PATH
     nano_init();
 #endif
diff --git a/audio/audio_hal/audio_hw.h b/audio/audio_hal/audio_hw.h
old mode 100755
new mode 100644
index 3cafe57..262219c
--- a/audio/audio_hal/audio_hw.h
+++ b/audio/audio_hal/audio_hw.h
@@ -96,6 +96,7 @@
 
 #define DDP_FRAME_SIZE      768
 #define EAC3_MULTIPLIER 4
+#define  JITTER_DURATION_MS  3
 enum {
     TYPE_PCM = 0,
     TYPE_AC3 = 2,
@@ -460,7 +461,7 @@
     //int cnt_stream_using_mixer;
     int tsync_fd;
     bool rawtopcm_flag;
-    bool is_ms12sys_lat;
+    bool is_netflix;
     int dtv_aformat;
     unsigned int dtv_i2s_clock;
     unsigned int dtv_spidif_clock;
@@ -483,8 +484,10 @@
     int start_mute_flag;
     int ad_start_enable;
     int count;
+    int sound_track_mode;
     void *alsa_handle[ALSA_DEVICE_CNT];
     bool dual_spdif_support; /*1 means supports spdif_a & spdif_b & spdif interface*/
+    uint64_t  sys_audio_frame_written;
 };
 
 struct meta_data {
@@ -526,12 +529,15 @@
     struct audio_config audioCfg;
     /* config which set to ALSA device */
     struct pcm_config config;
+    audio_format_t    alsa_output_format;
     /* channel mask exposed to AudioFlinger. */
     audio_channel_mask_t hal_channel_mask;
     /* format mask exposed to AudioFlinger. */
     audio_format_t hal_format;
     /* samplerate exposed to AudioFlinger. */
     unsigned int hal_rate;
+    unsigned int hal_ch;
+    unsigned int hal_frame_size;
     unsigned int rate_convert;
     audio_output_flags_t flags;
     audio_devices_t out_device;
@@ -556,6 +562,7 @@
     void *audioeffect_tmp_buffer;
     bool pause_status;
     bool hw_sync_mode;
+    int  tsync_status;
     float volume_l;
     float volume_r;
     float last_volume_l;
@@ -628,7 +635,13 @@
     bool dual_spdif;
     int codec_type2;  /*used for dual bitstream output*/
     struct pcm *pcm2; /*used for dual bitstream output*/
+    bool tv_src_stream;
+    unsigned int write_func;
+    uint64_t  last_frame_reported;
+    struct timespec  last_timestamp_reported;
     void    *pstMmapAudioParam;    // aml_mmap_audio_param_st (aml_mmap_audio.h)
+    bool ac3_parser_init;
+    void * ac3_parser_handle;
 };
 
 typedef ssize_t (*write_func)(struct audio_stream_out *stream, const void *buffer, size_t bytes);
diff --git a/audio/audio_hal/audio_hw_dtv.c b/audio/audio_hal/audio_hw_dtv.c
old mode 100755
new mode 100644
index 75ae20e..1e7275b
--- a/audio/audio_hal/audio_hw_dtv.c
+++ b/audio/audio_hal/audio_hw_dtv.c
@@ -73,6 +73,8 @@
 #define TSYNC_FIRST_VPTS "/sys/class/tsync/firstvpts"
 #define TSYNC_AUDIO_MODE "/sys/class/tsync_pcr/tsync_audio_mode"
 #define TSYNC_AUDIO_LEVEL "/sys/class/tsync_pcr/tsync_audio_level"
+#define TSYNC_VIDEO_DISCONT "/sys/class/tsync_pcr/tsync_vdiscontinue"
+
 #define TSYNC_LAST_DISCONTINUE_CHECKIN_APTS "/sys/class/tsync_pcr/tsync_last_discontinue_checkin_apts"
 #define TSYNC_LAST_CHECKIN_APTS "/sys/class/tsync/last_checkin_apts"
 
@@ -88,6 +90,9 @@
 #define TSYNC_PCR_LANTCY        "/sys/class/tsync/pts_latency"
 #define AMSTREAM_AUDIO_PORT_RESET   "/sys/class/amstream/reset_audio_port"
 #define VIDEO_FIRST_FRAME_SHOW  "/sys/module/amvideo/parameters/first_frame_toggled"
+#define VIDEO_DISPLAY_FRAME_CNT "/sys/module/amvideo/parameters/display_frame_count"
+#define VIDEO_RECEIVE_FRAME_CNT "/sys/module/amvideo/parameters/receive_frame_count"
+
 
 #define DTV_DECODER_PTS_LOOKUP_PATH "/sys/class/tsync/apts_lookup"
 #define DTV_DECODER_CHECKIN_FIRSTAPTS_PATH "/sys/class/tsync/checkin_firstapts"
@@ -380,6 +385,22 @@
     return a_discontinue;
 }
 
+static int get_video_discontinue(void)
+{
+    char tempbuf[128];
+    int pcr_vdiscontinue = 0, ret;
+    ret = aml_sysfs_get_str(TSYNC_VIDEO_DISCONT, tempbuf, sizeof(tempbuf));
+    if (ret > 0) {
+        ret = sscanf(tempbuf, "%d\n", &pcr_vdiscontinue);
+    }
+    if (ret > 0 && pcr_vdiscontinue > 0) {
+        pcr_vdiscontinue = (pcr_vdiscontinue & 0xff);
+    } else {
+        pcr_vdiscontinue = 0;
+    }
+    return pcr_vdiscontinue;
+}
+
 static void init_cmd_list(void)
 {
     dtv_cmd_list.next = NULL;
@@ -594,7 +615,7 @@
 
 static void dtv_do_ease_out(struct aml_audio_device *aml_dev)
 {
-    if (aml_dev && aml_dev->audio_ease) {
+    if (aml_dev && aml_dev->audio_ease && aml_dev->is_TV) {
         ALOGI("%s(), do fade out", __func__);
         start_ease_out(aml_dev);
         usleep(200 * 1000);
@@ -847,6 +868,73 @@
     return pcrpts;
 }
 
+static void dtv_av_pts_info(struct aml_audio_patch *patch, unsigned int apts, unsigned int pcrpts)
+{
+    unsigned int cur_vpts = 0;
+    unsigned int demux_vpts = 0;
+    unsigned int demux_apts = 0;
+    unsigned int demux_pcr = 0;
+    unsigned int firstvpts;
+    char buf[4096];
+    int video_display_frame_count = 0;
+    int video_receive_frame_count = 0;
+    int64_t av_diff_ms = 0;
+    int64_t ap_diff_ms = 0;
+    struct timespec now_time;
+    int time_cost_ms = 0;
+
+    get_sysfs_uint(TSYNC_VPTS, &cur_vpts);
+    get_sysfs_uint(TSYNC_DEMUX_APTS, &demux_apts);
+    get_sysfs_uint(TSYNC_DEMUX_VPTS, &demux_vpts);
+    get_sysfs_uint(TSYNC_DEMUX_PCR, &demux_pcr);
+    get_sysfs_uint(TSYNC_FIRST_VPTS, &firstvpts);
+    video_display_frame_count = get_sysfs_int(VIDEO_DISPLAY_FRAME_CNT);
+    video_receive_frame_count = get_sysfs_int(VIDEO_RECEIVE_FRAME_CNT);
+    av_diff_ms = (apts - cur_vpts) / 90;
+    ap_diff_ms = (pcrpts - apts) / 90;
+    ALOGI("dtv_av_info,diff:%d,apts:%x(%x,cache:%dms),vpts:%x(%x,cache:%dms),pcrpts:%x,av-diff:%d,size:%d,latency:%d,mode:%d,firstvpts:%d,v_show_cnt:%d,v_rev_cnt:%d\n",
+          (int)(pcrpts - apts) / 90, apts, demux_apts, (int)(demux_apts - apts) / 90,cur_vpts, demux_vpts, (int)(demux_vpts - cur_vpts) / 90, pcrpts,
+          (int)(apts - cur_vpts)/90, get_buffer_read_space(&(patch->aml_ringbuffer)), (int)decoder_get_latency() / 90, get_dtv_sync_mode(), firstvpts,
+          video_display_frame_count, video_receive_frame_count);
+
+    if (av_diff_ms > 150 && ap_diff_ms > 0 && ap_diff_ms < 100 && patch->dtv_log_retry_cnt++ > 4) {
+        patch->dtv_log_retry_cnt = 0;
+
+        clock_gettime(CLOCK_MONOTONIC, &now_time);
+        time_cost_ms = calc_time_interval_us(&patch->last_debug_record, &now_time) / 1000;
+        clock_gettime(CLOCK_MONOTONIC, &patch->last_debug_record);
+        // add calc to judge audio,video or pcr error.
+        if (patch->last_apts_record != 0) {
+            ALOGI("dtv_av_info, apts:0x%x, last_record=0x%x,apts diff:%lld ms, time_const=%d ms\n",
+                apts, patch->last_apts_record, (int64_t)(apts - patch->last_apts_record) / 90, time_cost_ms);
+        }
+        if (patch->last_pcrpts_record != 0) {
+            ALOGI("dtv_av_info, pcrpts:0x%x, last_record=0x%x,pcr diff:%lld ms, time_const=%d ms\n",
+                pcrpts, patch->last_pcrpts_record, (int64_t)(pcrpts - patch->last_pcrpts_record) / 90, time_cost_ms);
+        }
+        if (patch->last_vpts_record != 0) {
+            ALOGI("dtv_av_info, cur_vpts:0x%x, last_record=0x%x,vpts diff:%lld ms, time_const=%d ms\n",
+                cur_vpts, patch->last_vpts_record, (int64_t)(cur_vpts - patch->last_vpts_record) / 90, time_cost_ms);
+        }
+        patch->last_apts_record = apts;
+        patch->last_pcrpts_record = pcrpts;
+        patch->last_vpts_record = cur_vpts;
+
+        sysfs_get_sysfs_str("/sys/class/amstream/bufs", buf, sizeof(buf));
+        ALOGI("dtv_av_info, amstream bufs=%s\n", buf);
+        memset(buf, 0, sizeof(buf));
+        sysfs_get_sysfs_str("/sys/class/ppmgr/ppmgr_vframe_states", buf, sizeof(buf));
+        ALOGI("dtv_av_info, ppmgr states=%s\n", buf);
+        memset(buf, 0, sizeof(buf));
+        sysfs_get_sysfs_str("/sys/class/deinterlace/di0/provider_vframe_status", buf, sizeof(buf));
+        ALOGI("dtv_av_info, di states=%s\n", buf);
+        memset(buf, 0, sizeof(buf));
+        sysfs_get_sysfs_str("/sys/class/video/vframe_states", buf, sizeof(buf));
+        ALOGI("dtv_av_info, video states=%s\n", buf);
+    }
+
+}
+
 static int dtv_calc_abuf_level(struct aml_audio_patch *patch, struct aml_stream_out *stream_out)
 {
     if (!patch) {
@@ -924,7 +1012,7 @@
         get_sysfs_uint(TSYNC_FIRSTCHECKIN_VPTS, &first_checkinvpts);
         get_sysfs_uint(TSYNC_FIRST_VPTS, &first_vpts);
         get_sysfs_uint(TSYNC_LAST_CHECKIN_APTS, &last_checkinapts);
-        ALOGI("demux_pcr %x first_apts %x, last_checkinapts=%x, first_checkinvpts=%x, first_vpts: 0x%x(have_video:%d), discontinue %d, apts_diff=%d",
+        ALOGI("demux_pcr %x first_apts %x,last_checkinapts=%x,first_checkinvpts=%x,first_vpts:0x%x(has_video:%d),discontinue %d, apts_diff=%d",
                 demux_pcr, first_checkinapts, last_checkinapts, first_checkinvpts, first_vpts, patch->dtv_has_video, a_discontinue, *apts_diff);
     }
 
@@ -959,7 +1047,7 @@
     if (delay_ms * 90 > audio_latency) {
         audio_latency = delay_ms * 90;
     }
-    ALOGI("dtv_set_audio_latency: audio_latency=%d", audio_latency);
+    ALOGI("dtv_set_audio_latency: audio_latency=%d, apts_diff=%d", audio_latency, apts_diff);
 
     if (apts_diff == 0) {
         ret = aml_sysfs_get_str(TSYNC_APTS_DIFF, buff, sizeof(buff));
@@ -1033,18 +1121,20 @@
         type = 0;
     }
     if (type == 2) {
-        audio_format_t output_format = AUDIO_FORMAT_E_AC3;
+        audio_format_t output_format = AUDIO_FORMAT_IEC61937;
         size_t write_bytes = EAC3_IEC61937_FRAME_SIZE;
         //ALOGI("++aml_alsa_output_write E_AC3");
         if (audio_hal_data_processing(stream_out, (void*)mixbuffer, write_bytes, &output_buffer, &output_buffer_bytes, output_format) == 0) {
+            output_format = AUDIO_FORMAT_E_AC3;
             hw_write(stream_out, output_buffer, output_buffer_bytes, output_format);
         }
         //ALOGI("--aml_alsa_output_write E_AC3");
     } else if (type == 1) {
-        audio_format_t output_format = AUDIO_FORMAT_AC3;
+        audio_format_t output_format = AUDIO_FORMAT_IEC61937;
         size_t write_bytes = AC3_IEC61937_FRAME_SIZE;
         //ALOGI("++aml_alsa_output_write AC3");
         if (audio_hal_data_processing(stream_out, (void*)mixbuffer, write_bytes, &output_buffer, &output_buffer_bytes, output_format) == 0) {
+            output_format = AUDIO_FORMAT_AC3;
             hw_write(stream_out, output_buffer, output_buffer_bytes, output_format);
         }
         //ALOGI("--aml_alsa_output_write AC3");
@@ -1098,7 +1188,8 @@
         (patch->last_pcrpts != 0  && patch->last_pcrpts != (unsigned long) - 1)) {
         cur_pts_diff = patch->last_pcrpts - patch->last_apts;
         if (audio_discontinue == 0 &&
-            abs(cur_pts_diff) > DTV_PTS_CORRECTION_THRESHOLD * 5) {
+            abs(cur_pts_diff) > DTV_PTS_CORRECTION_THRESHOLD * 5 &&
+            get_video_discontinue() != 1) {
             audio_discontinue = 1;
             ALOGV("cur_pts_diff=%d, diff=%d, apts=0x%x, pcrpts=0x%x\n",
                 cur_pts_diff, cur_pts_diff/90, patch->last_apts, patch->last_pcrpts);
@@ -1114,10 +1205,10 @@
         }
         if (first_checkinapts) {
             patch->dtv_audio_tune = AUDIO_BREAK;
-            ALOGI("audio discontinue, audio_break");
+            ALOGI("audio discontinue, first_checkinapts tune -> AUDIO_BREAK");
         } else if (audio_discontinue == 1) {
             patch->dtv_audio_tune = AUDIO_BREAK;
-            ALOGI("audio_discontinue set 1,break\n");
+            ALOGI("audio_discontinue set 1, tune -> AUDIO_BREAK\n");
         }
     }
 }
@@ -1299,6 +1390,7 @@
                 pcrpts -= pts_diff;
                 decoder_set_pcrsrc(pcrpts);
             }
+            ALOGI("dtv_audio_tune_check, dtv_audio_tune AUDIO_LATENCY -> AUDIO_RUNNING");
             patch->dtv_audio_tune = AUDIO_RUNNING;
         }
         return 1;
@@ -1316,11 +1408,11 @@
     struct audio_hw_device *adev = patch->dev;
     struct aml_audio_device *aml_dev = (struct aml_audio_device *) adev;
     struct aml_mixer_handle * handle = &(aml_dev->alsa_mixer);
+
     if (get_tsync_pcr_debug()) {
-        ALOGI("process_pts_sync, diff:%d,pcrpts %x,size %d, latency %d, mode %d",
-              (int)(pcrpts - apts) / 90, pcrpts, get_buffer_read_space(&(patch->aml_ringbuffer)),
-              (int)decoder_get_latency() / 90, get_dtv_sync_mode());
+        dtv_av_pts_info(patch, apts, pcrpts);
     }
+
     last_apts = patch->last_apts;
     last_pcrpts = patch->last_pcrpts;
     patch->last_pcrpts = pcrpts;
@@ -1376,18 +1468,11 @@
     struct aml_audio_device *aml_dev = (struct aml_audio_device *) adev;
     struct aml_mixer_handle * handle = &(aml_dev->alsa_mixer);
     int ret = 0;
-    if (get_tsync_pcr_debug()) {
-        unsigned int cur_vpts = 0;
-        unsigned int demux_vpts = 0;
-        unsigned int demux_apts = 0;
-        get_sysfs_uint(TSYNC_VPTS, &cur_vpts);
-        get_sysfs_uint(TSYNC_DEMUX_APTS, &demux_apts);
-        get_sysfs_uint(TSYNC_DEMUX_VPTS, &demux_vpts);
 
-        ALOGI("process_ac3_sync, diff:%d,apts %x(%x,cache:%dms), vpts %x(%x,cache:%dms), pcrpts %x, av-diff:%d, size %d, latency %d, mode %d, pll_state=%d\n",
-              (int)(pcrpts - apts) / 90, apts, demux_apts, (int)(demux_apts - apts) / 90,cur_vpts, demux_vpts, (int)(demux_vpts - cur_vpts) / 90, pcrpts, (int)(apts - cur_vpts)/90,
-              get_buffer_read_space(&(patch->aml_ringbuffer)), (int)decoder_get_latency() / 90, get_dtv_sync_mode(), patch->pll_state);
+    if (get_tsync_pcr_debug()) {
+        dtv_av_pts_info(patch, apts, pcrpts);
     }
+
     last_apts = patch->last_apts;
     last_pcrpts = patch->last_pcrpts;
     patch->last_pcrpts = pcrpts;
@@ -1449,12 +1534,13 @@
     int symbol = 48;
     char tempbuf[128];
     unsigned int pcrpts;
-    unsigned int pts_diff;
+    unsigned int pts_diff,last_checkin_apts;
     unsigned long cur_out_pts;
 
     if (patch->dtv_first_apts_flag == 0) {
+        get_sysfs_uint(TSYNC_LAST_CHECKIN_APTS, &last_checkin_apts);
         sprintf(tempbuf, "AUDIO_START:0x%x", (unsigned int)pts);
-        ALOGI("dtv set tsync -> %s", tempbuf);
+        ALOGI("dtv set tsync -> %s, cache audio:%dms", tempbuf, (int)(last_checkin_apts - pts)/90);
         if (sysfs_set_sysfs_str(TSYNC_EVENT, tempbuf) == -1) {
             ALOGE("set AUDIO_START failed \n");
         }
@@ -1480,7 +1566,7 @@
     int bytewidth = 2;
     int sysmbol = 48;
     char tempbuf[128];
-    unsigned int pcrpts, apts;
+    unsigned int pcrpts, apts, last_checkin_apts;
     unsigned int calc_len = 0;
     unsigned long pts = 0, lookpts;
     unsigned long cache_pts = 0;
@@ -1495,8 +1581,10 @@
             pts = decoder_checkin_firstapts();
             ALOGI("pts = 0,so get checkin_firstapts:0x%lx", pts);
         }
+
+        get_sysfs_uint(TSYNC_LAST_CHECKIN_APTS, &last_checkin_apts);
         sprintf(tempbuf, "AUDIO_START:0x%x", (unsigned int)pts);
-        ALOGI("dtv set tsync -> %s", tempbuf);
+        ALOGI("dtv set tsync -> %s, audio cache:%dms", tempbuf, (int)(last_checkin_apts - pts)/90);
         if (sysfs_set_sysfs_str(TSYNC_EVENT, tempbuf) == -1) {
             ALOGE("set AUDIO_START failed \n");
         }
@@ -1540,7 +1628,7 @@
 {
     unsigned long pts;
     int audio_output_delay = 0;
-    unsigned int pcrpts, firstvpts, last_checkin_apts;
+    unsigned int pcrpts, firstvpts;
     ring_buffer_t *ringbuffer = &(patch->aml_ringbuffer);
     struct audio_hw_device *dev = patch->dev;
     struct aml_audio_device *aml_dev = (struct aml_audio_device *)dev;
@@ -1548,16 +1636,13 @@
         return;
     }
 
-    if (patch->show_first_frame == 0) {
-        patch->show_first_frame = get_sysfs_int(VIDEO_FIRST_FRAME_SHOW);
-        ALOGV("dtv_avsync_process: patch->show_first_frame=%d", patch->show_first_frame);
-    }
     get_sysfs_uint(TSYNC_PCRSCR, &pcrpts);
     get_sysfs_uint(TSYNC_FIRST_VPTS, &firstvpts);
-    if (get_tsync_pcr_debug()) {
-        get_sysfs_uint(TSYNC_LAST_CHECKIN_APTS, &last_checkin_apts);
-        ALOGI("dtv_avsync_process pcrpts: %x,last_checkinapts=%x, first_vpts: 0x%x\n",
-            pcrpts, last_checkin_apts, firstvpts);
+
+    if (patch->show_first_frame == 0) {
+        patch->show_first_frame = get_sysfs_int(VIDEO_FIRST_FRAME_SHOW);
+        ALOGI("dtv_avsync_process: patch->show_first_frame=%d, firstvpts=0x%x, pcrpts=0x%x, cache:%dms",
+            patch->show_first_frame, firstvpts, pcrpts, (int)(firstvpts - pcrpts)/90);
     }
 
     aml_dev->audio_discontinue = get_audio_discontinue();
@@ -1863,6 +1948,7 @@
                 return -EAGAIN;
             }
             patch->first_apts_lookup_over = 1;
+            ALOGI("[%s,%d] dtv_audio_tune %d-> AUDIO_LOOKUP\n", __FUNCTION__, __LINE__, patch->dtv_audio_tune);
             patch->dtv_audio_tune = AUDIO_LOOKUP;
             //ALOGI("dtv_audio_tune audio_lookup\n");
             clean_dtv_patch_pts(patch);
@@ -1876,6 +1962,7 @@
                 usleep(5000);
                 return -EAGAIN;
             }
+            ALOGI("[%s,%d] dtv_audio_tune AUDIO_BREAK-> AUDIO_LOOKUP\n", __FUNCTION__, __LINE__);
             patch->dtv_audio_tune = AUDIO_LOOKUP;
             //ALOGI("dtv_audio_tune audio_lookup\n");
             clean_dtv_patch_pts(patch);
@@ -1883,7 +1970,7 @@
         if (patch->dtv_audio_tune == AUDIO_DROP) {
             dtv_do_drop_pcm(avail, patch, stream_out);
             clean_dtv_patch_pts(patch);
-            //ALOGI("dtv_audio_tune audio_latency\n");
+            ALOGI("[%s,%d] dtv_audio_tune AUDIO_DROP-> AUDIO_LATENCY\n", __FUNCTION__, __LINE__);
             patch->dtv_audio_tune = AUDIO_LATENCY;
         }
         ret = ring_buffer_read(ringbuffer, (unsigned char *)patch->out_buf, write_len);
@@ -1941,7 +2028,6 @@
         if (aml_dev->ddp.curFrmSize != 0) {
             write_len = aml_dev->ddp.curFrmSize;
         }
-
         if (!patch->first_apts_lookup_over) {
             *apts_diff = dtv_set_audio_latency(0);
             if (!dtv_firstapts_lookup_over(patch, aml_dev, false, apts_diff) || avail < 512 * 2) {
@@ -1951,6 +2037,7 @@
                 return -EAGAIN;
             }
             patch->first_apts_lookup_over = 1;
+            ALOGI("[%s,%d] dtv_audio_tune %d-> AUDIO_LOOKUP\n", __FUNCTION__, __LINE__, patch->dtv_audio_tune);
             patch->dtv_audio_tune = AUDIO_LOOKUP;
             clean_dtv_patch_pts(patch);
             //ALOGI("dtv_audio_tune audio_lookup\n");
@@ -1963,6 +2050,7 @@
                 usleep(5000);
                 return -EAGAIN;
             }
+            ALOGI("[%s,%d] dtv_audio_tune AUDIO_BREAK-> AUDIO_LOOKUP\n", __FUNCTION__, __LINE__);
             patch->dtv_audio_tune = AUDIO_LOOKUP;
             clean_dtv_patch_pts(patch);
             //ALOGI("dtv_audio_tune audio_lookup\n");
@@ -1974,6 +2062,7 @@
                 clean_dtv_patch_pts(patch);
                 patch->dtv_apts_lookup = 0;
                 patch->ac3_pcm_dropping = 0;
+                ALOGI("[%s,%d] dtv_audio_tune AUDIO_DROP-> AUDIO_LATENCY\n", __FUNCTION__, __LINE__);
                 patch->dtv_audio_tune = AUDIO_LATENCY;
                 ALOGI("dtv_audio_tune ac3 audio_latency\n");
             }
@@ -2119,6 +2208,7 @@
                 return -EAGAIN;
             }
             patch->first_apts_lookup_over = 1;
+            ALOGI("[%s,%d] dtv_audio_tune %d-> AUDIO_LOOKUP\n", __FUNCTION__, __LINE__, patch->dtv_audio_tune);
             patch->dtv_audio_tune = AUDIO_LOOKUP;
             //ALOGI("dtv_audio_tune audio_lookup\n");
             clean_dtv_patch_pts(patch);
@@ -2133,6 +2223,7 @@
                 usleep(5000);
                 return -EAGAIN;
             }
+            ALOGI("[%s,%d] dtv_audio_tune AUDIO_BREAK-> AUDIO_LOOKUP\n", __FUNCTION__, __LINE__);
             patch->dtv_audio_tune = AUDIO_LOOKUP;
             //ALOGI("dtv_audio_tune audio_lookup\n");
             clean_dtv_patch_pts(patch);
@@ -2144,7 +2235,7 @@
                 clean_dtv_patch_pts(patch);
                 patch->dtv_apts_lookup = 0;
                 patch->ac3_pcm_dropping = 0;
-                ALOGI("dtv_audio_tune audio_latency\n");
+                ALOGI("[%s,%d] dtv_audio_tune AUDIO_DROP-> AUDIO_LATENCY\n", __FUNCTION__, __LINE__);
                 patch->dtv_audio_tune = AUDIO_LATENCY;
             }
         }
@@ -2361,7 +2452,7 @@
     ret = adev_open_output_stream_new(patch->dev, 0,
                                       patch->output_src,        // devices_t
                                       AUDIO_OUTPUT_FLAG_DIRECT, // flags
-                                      &stream_config, &stream_out, NULL);
+                                      &stream_config, &stream_out, "AML_TV_SOURCE");
     if (ret < 0) {
         ALOGE("live open output stream fail, ret = %d", ret);
         goto exit_open;
@@ -2893,15 +2984,15 @@
 int release_dtv_patch_l(struct aml_audio_device *aml_dev)
 {
     if (aml_dev == NULL) {
-        ALOGI("[%s]release the dtv patch failed  aml_dev == NULL\n", __FUNCTION__);
-        return -1;
+        ALOGI("[%s]release the dtv patch aml_dev == NULL\n", __FUNCTION__);
+        return 0;
     }
     struct aml_audio_patch *patch = aml_dev->audio_patch;
 
     ALOGI("++%s live\n", __FUNCTION__);
     if (patch == NULL) {
-        ALOGI("release the dtv patch failed  patch == NULL\n");
-        return -1;
+        ALOGI("release the dtv patch patch == NULL\n");
+        return 0;
     }
     deinit_cmd_list();
     patch->input_thread_exit = 1;
diff --git a/audio/audio_hal/audio_hw_profile.c b/audio/audio_hal/audio_hw_profile.c
old mode 100755
new mode 100644
index 9fa84f4..3d554ac
--- a/audio/audio_hal/audio_hw_profile.c
+++ b/audio/audio_hal/audio_hw_profile.c
@@ -109,6 +109,9 @@
                 size += sprintf(aud_cap + size, "|%s", "AUDIO_FORMAT_E_AC3");
                 p_hdmi_descs->ddp_fmt.is_support = 1;
             }
+            if (mystrstr(infobuf, "ATMOS")) {
+                size += sprintf(aud_cap + size, "|%s", "AUDIO_FORMAT_E_AC3_JOC");
+            }
             if (mystrstr(infobuf, "AC-3")) {
                 size += sprintf(aud_cap + size, "|%s", "AUDIO_FORMAT_AC3");
                 p_hdmi_descs->dd_fmt.is_support = 1;
@@ -130,10 +133,10 @@
             ALOGD("query hdmi channels...\n");
             /* take the 2ch suppported as default */
             size += sprintf(aud_cap, "sup_channels=%s", "AUDIO_CHANNEL_OUT_STEREO");
-            if (mystrstr(infobuf, "PCM, 8 ch") ||
+            if (/*(!alsa_device_is_auge() && mystrstr(infobuf, "PCM, 8 ch")) ||*/
                 (mystrstr(infobuf, "Dobly_Digital+") && format == AUDIO_FORMAT_E_AC3)) {
                 size += sprintf(aud_cap + size, "|%s", "AUDIO_CHANNEL_OUT_5POINT1|AUDIO_CHANNEL_OUT_7POINT1");
-            } else if (mystrstr(infobuf, "PCM, 6 ch") ||
+            } else if (/*(!alsa_device_is_auge() && mystrstr(infobuf, "PCM, 6 ch")) ||*/
                        (mystrstr(infobuf, "AC-3") && format == AUDIO_FORMAT_AC3) ||
                        /* backward compatibility for dd, if TV only supports dd+ */
                        (mystrstr(infobuf, "Dobly_Digital+") && format == AUDIO_FORMAT_AC3)) {
@@ -220,11 +223,14 @@
         /* check the format cap */
         if (strstr(keys, AUDIO_PARAMETER_STREAM_SUP_FORMATS)) {
             ALOGD("query hdmi format...\n");
-            size += sprintf(aud_cap, "sup_formats=%s", "AUDIO_FORMAT_PCM_16_BIT");
+            size += sprintf(aud_cap, "sup_formats=%s", "AUDIO_FORMAT_PCM_16_BIT|AUDIO_FORMAT_IEC61937");
             if (mystrstr(infobuf, "Dobly_Digital+") || dolby_decoder_sup) {
                 size += sprintf(aud_cap + size, "|%s", "AUDIO_FORMAT_E_AC3");
                 p_hdmi_descs->ddp_fmt.is_support = 1;
             }
+            if (mystrstr(infobuf, "ATMOS")) {
+                size += sprintf(aud_cap + size, "|%s", "AUDIO_FORMAT_E_AC3_JOC");
+            }
             if (mystrstr(infobuf, "AC-3")) {
                 size += sprintf(aud_cap + size, "|%s", "AUDIO_FORMAT_AC3");
                 p_hdmi_descs->dd_fmt.is_support = 1;
@@ -245,10 +251,10 @@
             ALOGD("query hdmi channels...\n");
             /* take the 2ch suppported as default */
             size += sprintf(aud_cap, "sup_channels=%s", "AUDIO_CHANNEL_OUT_STEREO");
-            if (mystrstr(infobuf, "PCM, 8 ch") ||
+            if (/*(!alsa_device_is_auge() && mystrstr(infobuf, "PCM, 8 ch")) ||*/
                 ((mystrstr(infobuf, "Dobly_Digital+") || dolby_decoder_sup )&& format == AUDIO_FORMAT_E_AC3)) {
                 size += sprintf(aud_cap + size, "|%s", "AUDIO_CHANNEL_OUT_5POINT1|AUDIO_CHANNEL_OUT_7POINT1");
-            } else if (mystrstr(infobuf, "PCM, 6 ch") ||
+            } else if (/*(!alsa_device_is_auge() && mystrstr(infobuf, "PCM, 6 ch")) ||*/
                        (mystrstr(infobuf, "AC-3") && format == AUDIO_FORMAT_AC3) ||
                        /* backward compatibility for dd, if TV only supports dd+ */
                        (mystrstr(infobuf, "Dobly_Digital+") && format == AUDIO_FORMAT_AC3)) {
diff --git a/audio/audio_hal/audio_hw_utils.c b/audio/audio_hal/audio_hw_utils.c
old mode 100755
new mode 100644
index 66e6b62..318c603
--- a/audio/audio_hal/audio_hw_utils.c
+++ b/audio/audio_hal/audio_hw_utils.c
@@ -44,8 +44,9 @@
 #include "audio_hw.h"
 #include "amlAudioMixer.h"
 #include <audio_utils/primitives.h>
-#include "a2dp_hal.h"
 #include "alsa_device_parser.h"
+#include "a2dp_hal.h"
+#include "aml_audio_avsync_table.h"
 
 #ifdef LOG_NDEBUG_FUNCTION
 #define LOGFUNC(...) ((void)0)
@@ -199,8 +200,10 @@
         return -1;
     }
     if (sscanf(valstr, "0x%x", &val) < 1) {
-        ALOGE("unable to get pts from: %s", valstr);
-        return -1;
+        if (sscanf(valstr, "%u", &val) < 1) {
+            ALOGE("unable to get pts from: %s", valstr);
+            return -1;
+        }
     }
     *value = val;
     return 0;
@@ -221,6 +224,24 @@
     return -1;
 }
 
+int sysfs_get_sysfs_str(const char *path, char *valstr, int size)
+{
+    int fd;
+    fd = open(path, O_RDONLY);
+    if (fd >= 0) {
+        memset(valstr,0,size);
+        read(fd, valstr, size - 1);
+        valstr[strlen(valstr)] = '\0';
+        close(fd);
+    } else {
+        ALOGE("unable to open file %s,err: %s", path, strerror(errno));
+        sprintf(valstr, "%s", "fail");
+        return -1;
+    };
+    return 0;
+}
+
+
 int get_sysfs_int(const char *path)
 {
     int val = 0;
@@ -574,7 +595,7 @@
     char *prop_name = NULL;
     (void)aformat;
     prop_name = "vendor.media.audio.hal.latency.ddp";
-    latency_ms = -50;
+    latency_ms = -80;
     ret = property_get(prop_name, buf, NULL);
     if (ret > 0) {
         latency_ms = atoi(buf);
@@ -590,7 +611,7 @@
     char *prop_name = NULL;
     (void)aformat;
     prop_name = "vendor.media.audio.hal.latency.pcm";
-    latency_ms = -30;
+    latency_ms = 30;
     ret = property_get(prop_name, buf, NULL);
     if (ret > 0) {
         latency_ms = atoi(buf);
@@ -599,20 +620,24 @@
 }
 
 
-int aml_audio_get_hwsync_latency_offset(void)
+int aml_audio_get_hwsync_latency_offset(bool b_raw)
 {
-	char buf[PROPERTY_VALUE_MAX];
-	int ret = -1;
-	int latency_ms = 0;
-	char *prop_name = NULL;
-
-	prop_name = "vendor.media.audio.hal.hwsync_latency.ddp";
-	latency_ms = -50;
-	ret = property_get(prop_name, buf, NULL);
-	if (ret > 0) {
-		latency_ms = atoi(buf);
-	}
-	return latency_ms;
+    char buf[PROPERTY_VALUE_MAX];
+    int ret = -1;
+    int latency_ms = 0;
+    char *prop_name = NULL;
+    if (!b_raw) {
+        prop_name = "vendor.media.audio.hal.hwsync_latency.pcm";
+        latency_ms = 60;
+    } else {
+        prop_name = "vendor.media.audio.hal.hwsync_latency.ddp";
+        latency_ms = -50;
+    }
+    ret = property_get(prop_name, buf, NULL);
+    if (ret > 0) {
+        latency_ms = atoi(buf);
+    }
+    return latency_ms;
 }
 
 int aml_audio_get_ms12_latency_offset(int b_raw)
@@ -623,30 +648,40 @@
     char *prop_name = NULL;
     if (b_raw == 0) {
         /*for non tunnel ddp2h/heaac case:netlfix AL1 case */
-        prop_name = "vendor.media.audio.hal.ms12.latency.pcm";
-        latency_ms = -50;
+        prop_name = AVSYNC_MS12_NONTUNNEL_PCM_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_MS12_NONTUNNEL_PCM_LATENCY;
     }else {
         /*for non tunnel dolby ddp5.1 case:netlfix AL1 case*/
-        prop_name = "vendor.media.audio.hal.ms12.latency.raw";
-        latency_ms = -70;
+        prop_name = AVSYNC_MS12_NONTUNNEL_RAW_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_MS12_NONTUNNEL_RAW_LATENCY;
     }
 
     ret = property_get(prop_name, buf, NULL);
     if (ret > 0) {
         latency_ms = atoi(buf);
     }
-    return latency_ms;
+    /*because the caller use add fucntion, instead of minus, so we return the minus value*/
+    return -latency_ms;
 }
 
-int aml_audio_get_ms12_tunnel_latency_offset(void)
+int aml_audio_get_ms12_tunnel_latency_offset(int b_raw)
 {
     char buf[PROPERTY_VALUE_MAX];
     int ret = -1;
     int latency_ms = 0;
     char *prop_name = NULL;
     /*tunnle mode case*/
-    prop_name = "vendor.media.audio.hal.ms12.latency.tunnel";
-    latency_ms = 50;
+    latency_ms = 0;
+
+    if (b_raw == 0) {
+        /*for non tunnel ddp2h/heaac case:netlfix AL1 case */
+        prop_name = AVSYNC_MS12_TUNNEL_PCM_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_MS12_TUNNEL_PCM_LATENCY;
+    } else {
+        /*for non tunnel dolby ddp5.1 case:netlfix AL1 case*/
+        prop_name = AVSYNC_MS12_TUNNEL_RAW_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_MS12_TUNNEL_RAW_LATENCY;
+    }
 
     ret = property_get(prop_name, buf, NULL);
     if (ret > 0) {
@@ -664,12 +699,12 @@
     char *prop_name = NULL;
     if (tunnel) {
         /*tunnel atmos case*/
-        prop_name = "vendor.media.audio.hal.ms12.latency.atmos.tunnel";
-        latency_ms = 100;
+        prop_name = AVSYNC_MS12_TUNNEL_ATMOS_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_MS12_TUNNEL_ATMOS_LATENCY;
     }else {
         /*non tunnel atmos case*/
-        prop_name = "vendor.media.audio.hal.ms12.latency.atmos.notunnel";
-        latency_ms = 50;
+        prop_name = AVSYNC_MS12_NONTUNNEL_ATMOS_LATENCY_PROPERTY;
+        latency_ms = AVSYNC_MS12_NONTUNNEL_ATMOS_LATENCY;
     }
     ret = property_get(prop_name, buf, NULL);
     if (ret > 0) {
@@ -753,6 +788,29 @@
     return frames / mul;
 }
 
+uint32_t out_get_alsa_latency_frames(const struct audio_stream_out *stream)
+{
+    const struct aml_stream_out *out = (const struct aml_stream_out *)stream;
+    snd_pcm_sframes_t frames = 0;
+    uint32_t whole_latency_frames;
+    int ret = 0;
+    int codec_type = get_codec_type(out->hal_internal_format);
+    int mul = 1;
+
+    if (is_4x_rate_fmt(codec_type))
+        mul = 4;
+
+    whole_latency_frames = out->config.period_size * out->config.period_count / 2;
+    if (!out->pcm || !pcm_is_ready(out->pcm)) {
+        return whole_latency_frames / mul;
+    }
+    ret = pcm_ioctl(out->pcm, SNDRV_PCM_IOCTL_DELAY, &frames);
+    if (ret < 0) {
+        return whole_latency_frames / mul;
+    }
+    return frames / mul;
+}
+
 uint32_t out_get_ms12_latency_frames(const struct audio_stream_out *stream)
 {
     const struct aml_stream_out *hal_out = (const struct aml_stream_out *)stream;
@@ -1017,6 +1075,11 @@
                 buf[i] = buf[i + 1];
                 buf[i + 1] = tmp;
                 break;
+            case AM_AOUT_OUTPUT_LRMIX:
+                tmp = (buf[i] / 2)  + (buf[i + 1] / 2);
+                buf[i] = tmp;
+                buf[i + 1] = tmp;
+                break;
             default :
                 break;
         }
diff --git a/audio/audio_hal/audio_hw_utils.h b/audio/audio_hal/audio_hw_utils.h
old mode 100755
new mode 100644
index 19ffca1..186985f
--- a/audio/audio_hal/audio_hw_utils.h
+++ b/audio/audio_hal/audio_hw_utils.h
@@ -54,9 +54,9 @@
 int aml_audio_get_arc_latency_offset(int format);
 int aml_audio_get_ddp_latency_offset(int format);
 int aml_audio_get_pcm_latency_offset(int format);
-int aml_audio_get_hwsync_latency_offset(void);
+int aml_audio_get_hwsync_latency_offset(bool b_raw);
 int aml_audio_get_ms12_latency_offset(int b_raw);
-int aml_audio_get_ms12_tunnel_latency_offset(void);
+int aml_audio_get_ms12_tunnel_latency_offset(int b_raw);
 int aml_audio_get_ms12_atmos_latency_offset(int tunnel);
 int aml_audio_get_ddp_frame_size();
 bool is_stream_using_mixer(struct aml_stream_out *out);
@@ -66,7 +66,7 @@
 int aml_audio_get_spdif_tuning_latency(void);
 int aml_audio_get_arc_tuning_latency(audio_format_t arc_afmt);
 int aml_audio_get_src_tune_latency(enum patch_src_assortion patch_src);
-int sysfs_get_sysfs_str(const char *path, const char *val, int len);
+int sysfs_get_sysfs_str(const char *path, char *val, int len);
 void audio_fade_func(void *buf,int fade_size,int is_fadein);
 void ts_wait_time_us(struct timespec *ts, uint32_t time_us);
 int cpy_16bit_data_with_gain(int16_t *dst, int16_t *src, int size_in_bytes, float vol);
@@ -83,5 +83,6 @@
 int halformat_convert_to_spdif(audio_format_t format);
 int alsa_device_get_port_index(alsa_device_t alsa_device);
 int aml_set_thread_priority(char *pName, pthread_t threadId);
+uint32_t out_get_alsa_latency_frames(const struct audio_stream_out *stream);
 
 #endif
diff --git a/audio/audio_hal/audio_hwsync.c b/audio/audio_hal/audio_hwsync.c
old mode 100755
new mode 100644
index c940a17..bce91d3
--- a/audio/audio_hal/audio_hwsync.c
+++ b/audio/audio_hal/audio_hwsync.c
@@ -171,6 +171,7 @@
         ALOGI("%s open tsync fd %d", __func__, fd);
     }
     ALOGI("%s done", __func__);
+    out->tsync_status = TSYNC_STATUS_INIT;
     return;
 }
 void aml_audio_hwsync_release(audio_hwsync_t *p_hwsync)
@@ -328,7 +329,7 @@
 
     if (aml_hwsync_set_tsync_start_pts(pts32) < 0)
         return -EINVAL;
-
+    p_hwsync->aout->tsync_status = TSYNC_STATUS_RUNNING;
     return 0;
 }
 /*
@@ -350,6 +351,8 @@
     uint32_t latency_frames = 0;
     struct audio_stream_out *stream = NULL;
     uint32_t latency_pts = 0;
+    struct aml_stream_out  *out = p_hwsync->aout;
+    int b_raw = 0;
 
     // add protection to avoid NULL pointer.
     if (p_hwsync == NULL) {
@@ -368,6 +371,14 @@
         }
     }
 
+    /*when it is ddp 2ch/heaac we need use different latency control*/
+    if (audio_is_linear_pcm(out->hal_internal_format)) {
+        b_raw = 0;
+    }else {
+        b_raw = 1;
+    }
+
+
     ret = aml_audio_hwsync_lookup_apts(p_hwsync, offset, &apts);
 
     /*get MS12 pipe line delay + alsa delay*/
@@ -377,7 +388,7 @@
             /*we need get the correct ms12 out pcm */
             latency_frames = out_get_ms12_latency_frames(stream);
             //ALOGI("latency_frames =%d", latency_frames);
-            latency_frames += aml_audio_get_ms12_tunnel_latency_offset()*48; // add 60ms delay for ms12, 32ms pts offset, other is ms12 delay
+            latency_frames += aml_audio_get_ms12_tunnel_latency_offset(b_raw)*48; // add 60ms delay for ms12, 32ms pts offset, other is ms12 delay
 
             if ((adev->ms12.is_dolby_atmos && adev->ms12_main1_dolby_dummy == false) || adev->atoms_lock_flag) {
                 int tunnel = 1;
@@ -496,7 +507,7 @@
     size_t align  = 0;
     int ret = -1;
     struct aml_audio_device *adev = NULL;
-    struct audio_stream_out *stream = NULL;
+    struct aml_stream_out  *out = NULL;
     int    debug_enable = 0;
     //struct aml_audio_device *adev = p_hwsync->aout->dev;
     //struct audio_stream_out *stream = (struct audio_stream_out *)p_hwsync->aout;
@@ -504,6 +515,10 @@
     uint32_t latency_frames = 0;
     uint32_t latency_pts = 0;
     apts_tab_t *pts_tab = NULL;
+    uint32_t nearest_pts = 0;
+    uint32_t nearest_offset = 0;
+    uint32_t min_offset = 0x7fffffff;
+    int match_index = -1;
 
     // add protection to avoid NULL pointer.
     if (!p_hwsync) {
@@ -515,8 +530,8 @@
         ALOGE("%s,p_hwsync->aout == NULL", __func__);
         return -1;
     }
-    stream = (struct audio_stream_out *)p_hwsync->aout;
 
+    out = p_hwsync->aout;
     adev = p_hwsync->aout->dev;
     if (adev == NULL) {
         ALOGE("%s,adev == NULL", __func__);
@@ -545,6 +560,7 @@
         if (pts_tab[i].valid) {
             if (pts_tab[i].offset == align) {
                 *p_apts = pts_tab[i].pts;
+                nearest_offset = pts_tab[i].offset;
                 ret = 0;
                 if (debug_enable) {
                     ALOGI("%s first flag %d,pts checkout done,offset %zu,align %zu,pts 0x%x",
@@ -552,12 +568,40 @@
                 }
                 break;
             } else if (pts_tab[i].offset < align) {
+                /*find the nearest one*/
+                if ((align - pts_tab[i].offset) < min_offset) {
+                    min_offset = align - pts_tab[i].offset;
+                    match_index = i;
+                    nearest_pts = pts_tab[i].pts;
+                    nearest_offset = pts_tab[i].offset;
+                }
                 pts_tab[i].valid = 0;
+
             }
         }
     }
     if (i == HWSYNC_APTS_NUM) {
-        ALOGE("%s,apts lookup failed,align %zu,offset %zu", __func__, align, offset);
+        if (nearest_pts) {
+            ret = 0;
+            *p_apts = nearest_pts;
+            ALOGI("find nearest pts 0x%x offset %zu align %zu", *p_apts, nearest_offset, align);
+        } else {
+            ALOGE("%s,apts lookup failed,align %zu,offset %zu", __func__, align, offset);
+        }
+    }
+    if ((ret == 0) && audio_is_linear_pcm(out->hal_internal_format)) {
+        int diff = 0;
+        int pts_diff = 0;
+        uint32_t frame_size = out->hal_frame_size;
+        uint32_t sample_rate  = out->hal_rate;
+        diff = (offset >= nearest_offset) ? (offset - nearest_offset) : 0;
+        if ((frame_size != 0) && (sample_rate != 0)) {
+            pts_diff = (diff * 1000/frame_size)/sample_rate;
+        }
+        *p_apts +=  pts_diff * 90;
+        if (debug_enable) {
+            ALOGI("data offset =%d pts offset =%d diff =%d pts=0x%x pts diff =%d", offset, nearest_offset, offset - nearest_offset, *p_apts, pts_diff);
+        }
     }
     pthread_mutex_unlock(&p_hwsync->lock);
     return ret;
diff --git a/audio/audio_hal/audio_hwsync.h b/audio/audio_hal/audio_hwsync.h
old mode 100755
new mode 100644
index 3792531..14cc522
--- a/audio/audio_hal/audio_hwsync.h
+++ b/audio/audio_hal/audio_hwsync.h
@@ -44,6 +44,7 @@
 #define APTS_DISCONTINUE_THRESHOLD          (90000/10*11)
 #define APTS_DISCONTINUE_THRESHOLD_MIN    (90000/1000*100)
 #define APTS_DISCONTINUE_THRESHOLD_MIN_35MS    (90000/1000*35)
+
 #define APTS_DISCONTINUE_THRESHOLD_MAX    (5*90000)
 
 #define HWSYNC_APTS_NUM     512
@@ -54,6 +55,13 @@
     RESYNC,        // pts need resync
 };
 
+enum tsync_status {
+    TSYNC_STATUS_INIT,
+    TSYNC_STATUS_RUNNING,
+    TSYNC_STATUS_PAUSED,
+    TSYNC_STATUS_STOP
+};
+
 typedef struct apts_tab {
     int  valid;
     size_t offset;
diff --git a/audio/audio_hal/audio_port.c b/audio/audio_hal/audio_port.c
old mode 100755
new mode 100644
index 40441e2..1c13cc7
--- a/audio/audio_hal/audio_port.c
+++ b/audio/audio_hal/audio_port.c
@@ -498,6 +498,7 @@
         }
     }
 
+    aml_audio_switch_output_mode((int16_t *)buffer, bytes, port->sound_track_mode);
     do {
         int written = 0;
         ALOGV("%s(), line %d", __func__, __LINE__);
diff --git a/audio/audio_hal/audio_port.h b/audio/audio_hal/audio_port.h
old mode 100755
new mode 100644
index 10e9dec..31e0291
--- a/audio/audio_hal/audio_port.h
+++ b/audio/audio_hal/audio_port.h
@@ -137,6 +137,7 @@
     pthread_cond_t cond;
     ssize_t (*write)(struct output_port *port, void *buffer, int bytes);
     struct timespec tval_last;
+    int sound_track_mode;
 };
 bool is_inport_valid(aml_mixer_input_port_type_e index);
 bool is_outport_valid(enum MIXER_OUTPUT_PORT index);
diff --git a/audio/audio_hal/hw_avsync_callbacks.c b/audio/audio_hal/hw_avsync_callbacks.c
old mode 100755
new mode 100644
index 55fceca..4ee650a
--- a/audio/audio_hal/hw_avsync_callbacks.c
+++ b/audio/audio_hal/hw_avsync_callbacks.c
@@ -9,6 +9,7 @@
 #include "audio_hw.h"
 #include "audio_hw_utils.h"
 
+
 enum hwsync_status pcm_check_hwsync_status(uint apts_gap)
 {
     enum hwsync_status sync_status;
@@ -59,7 +60,7 @@
     uint32_t sample_rate = 48000;
     uint64_t pts_delta = 0;
     int ret = 0;
-    uint32_t tunning_latency = 40;
+    int32_t tunning_latency = aml_audio_get_hwsync_latency_offset(false);
 
     if (!cookie || !header) {
         ALOGE("NULL pointer");
@@ -119,20 +120,23 @@
 
 
     if (!out->first_pts_set) {
-        uint32_t latency = 0;
+        int32_t latency = 0;
         int vframe_ready_cnt = 0;
         int delay_count = 0;
         hwsync_header_construct(header);
-        latency = out_get_outport_latency((struct audio_stream_out *)out);
-        latency += tunning_latency;
+        latency = (int32_t)out_get_outport_latency((struct audio_stream_out *)out) * 90;
+        latency += tunning_latency * 90;
         ALOGD("%s(), set tsync start pts %d, latency %d, last position %lld",
             __func__, pts32, latency, out->last_frames_postion);
-
-        if (pts32 < latency*90) {
-            ALOGI("pts32 = %d latency=%d", pts32/90, latency);
-            return 0;
+        if (latency < 0) {
+            pts32 += abs(latency);
+        } else {
+            if (pts32 < latency) {
+                ALOGI("pts32 = %d latency=%d", pts32/90, latency);
+                return 0;
+            }
+            pts32 -= latency;
         }
-        pts32 -= latency*90;
         while (delay_count < 10) {
             vframe_ready_cnt = get_sysfs_int("/sys/class/video/vframe_ready_cnt");
             ALOGV("/sys/class/video/vframe_ready_cnt is %d", vframe_ready_cnt);
@@ -153,15 +157,19 @@
         uint32_t pcr = 0;
         uint32_t apts_gap;
         // adjust pts based on latency which is only the outport latency
-        uint64_t latency = out_get_outport_latency((struct audio_stream_out *)out) * 90;
+        int32_t latency = (int32_t)out_get_outport_latency((struct audio_stream_out *)out) * 90;
         latency += tunning_latency * 90;
         // check PTS discontinue, which may happen when audio track switching
         // discontinue means PTS calculated based on first_apts and frame_write_sum
         // does not match the timestamp of next audio samples
-        if (pts32 > latency) {
-            pts32 -= latency;
+        if (latency < 0) {
+            pts32 += abs(latency);
         } else {
-            pts32 = 0;
+            if (pts32 > latency) {
+                pts32 -= latency;
+            } else {
+                pts32 = 0;
+            }
         }
 
         hwsync_extractor = out->hwsync_extractor;
@@ -172,7 +180,7 @@
                     __func__, adev->tsync_fd, ret);
         }
         if (out->debug_stream)
-            ALOGD("%s()audio pts %dms, pcr %dms, latency %lldms, diff %dms",
+            ALOGD("%s()audio pts %dms, pcr %dms, latency %dms, diff %dms",
                 __func__, pts32/90, pcr/90, latency/90,
                 (pts32 > pcr) ? (pts32 - pcr)/90 : (pcr - pts32)/90);
         apts_gap = get_pts_gap(pcr, pts32);
@@ -185,6 +193,11 @@
             /*when resume, we need do exactly sync fisrt*/
             out->need_first_sync = false;
             sync_status = ADJUSTMENT;
+        } else if (pcr == 0) {
+            /*during video stop, pcr has been reset by video
+              we need ignore such pcr value*/
+            ALOGI("pcr is reset by video");
+            sync_status = CONTINUATION;
         }
         // limit the gap handle to 0.5~5 s.
         if (sync_status == ADJUSTMENT) {
diff --git a/audio/audio_hal/spdif_encoder_api.c b/audio/audio_hal/spdif_encoder_api.c
index 860c4ef..a769f7b 100644
--- a/audio/audio_hal/spdif_encoder_api.c
+++ b/audio/audio_hal/spdif_encoder_api.c
@@ -35,6 +35,7 @@
     void *temp_buf;
     int temp_buf_size;
     int temp_buf_pos;
+    bool bmute;
 };
 
 
@@ -100,6 +101,7 @@
     }
 
     phandle->format = format;
+    phandle->bmute  = 0;
     *spdifenc_handle = (void *)phandle;
     ALOGI("%s handle =%p", __FUNCTION__, phandle);
     return 0;
@@ -147,8 +149,26 @@
     }
     spdif_encoder_ad_flush_output_current_position(spdifenc_handle->spdif_encoder_ad);
 
+    if (spdifenc_handle->bmute) {
+        /*why we just memset it? because it is not always one frame*/
+        if (spdifenc_handle->temp_buf_pos > 0) {
+            memset(spdifenc_handle->temp_buf, 0, spdifenc_handle->temp_buf_pos);
+        }
+    }
     *output_buf = spdifenc_handle->temp_buf;
     *out_size   = spdifenc_handle->temp_buf_pos;
+
     ALOGV("spdif enc format=0x%x size =0x%x", spdifenc_handle->format, *out_size);
     return 0;
 }
+
+int aml_spdif_encoder_mute(void *phandle, bool bmute) {
+    struct aml_spdif_encoder *spdifenc_handle = (struct aml_spdif_encoder *)phandle;
+    if (phandle == NULL) {
+        return -1;
+    }
+
+    spdifenc_handle->bmute  = bmute;
+    return 0;
+}
+
diff --git a/audio/audio_hal/spdif_encoder_api.h b/audio/audio_hal/spdif_encoder_api.h
index 104fc86..e6d5785 100644
--- a/audio/audio_hal/spdif_encoder_api.h
+++ b/audio/audio_hal/spdif_encoder_api.h
@@ -20,6 +20,7 @@
 int aml_spdif_encoder_open(void **spdifenc_handle, audio_format_t format);
 int aml_spdif_encoder_close(void *phandle);
 int aml_spdif_encoder_process(void *phandle, const void *buffer, size_t numBytes, void **output_buf, size_t *out_size);
+int aml_spdif_encoder_mute(void *phandle, bool bmute);
 
 
 
diff --git a/audio/audio_hal/sub_mixing_factory.c b/audio/audio_hal/sub_mixing_factory.c
old mode 100755
new mode 100644
index bb78fc1..fd68b4d
--- a/audio/audio_hal/sub_mixing_factory.c
+++ b/audio/audio_hal/sub_mixing_factory.c
@@ -289,7 +289,7 @@
         //TODO
         if (out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP)
             latency_frames = mixer_get_inport_latency_frames(audio_mixer, out->enInputPortType)
-                    + a2dp_out_get_latency(stream) * out->hal_rate / 1000;
+                    + a2dp_out_get_latency(stream);
         else
             latency_frames = mixer_get_inport_latency_frames(audio_mixer, out->enInputPortType)
                     + mixer_get_outport_latency_frames(audio_mixer);
@@ -654,27 +654,7 @@
     }
 
     if (out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
-        struct timespec stCurTimestamp;
-        int64_t  curr_nanoseconds = 0;
-        int64_t  pre_nanoseconds = 0;
-        int64_t  time_diff = 0;
-        int drift_frames = 0;
-
-        pre_nanoseconds = (long long)out->timestamp.tv_sec * 1000000000 + (long long)out->timestamp.tv_nsec;
-        clock_gettime(CLOCK_MONOTONIC, &stCurTimestamp);
-        curr_nanoseconds = (long long)stCurTimestamp.tv_sec * 1000000000 + (long long)stCurTimestamp.tv_nsec;
-        time_diff = curr_nanoseconds - pre_nanoseconds;
-        if (time_diff <= 100*1000000) {
-            drift_frames = (time_diff * 441) / 10000000;
-            if (adev->debug_flag)
-                ALOGI("[%s:%d] normal time diff=%lld drift_frames=%d", __func__, __LINE__,time_diff, drift_frames);
-        } else {
-            if (adev->debug_flag)
-                ALOGW("[%s:%d] big time diff:%lld", __func__, __LINE__, time_diff);
-            time_diff = 0;
-            drift_frames = 0;
-        }
-        *frames = frames_written_hw + drift_frames;
+        *frames = frames_written_hw;
         *timestamp = out->timestamp;
     } else if (!adev->audio_patching) {
         ret = mixer_get_presentation_position(audio_mixer,
@@ -1170,18 +1150,7 @@
     aml_out->lasttimestamp.tv_sec = aml_out->timestamp.tv_sec;
     aml_out->lasttimestamp.tv_nsec = aml_out->timestamp.tv_nsec;
 
-
-    if (aml_out->out_device & AUDIO_DEVICE_OUT_ALL_A2DP) {
-        uint64_t latency_frames = aml_out->hal_rate * a2dp_out_get_latency(stream) / 1000 +
-                mixer_get_inport_latency_frames(sm->mixerData, aml_out->enInputPortType);
-        if (aml_out->frame_write_sum > latency_frames)
-            aml_out->last_frames_postion = aml_out->frame_write_sum - latency_frames;
-        else
-            aml_out->last_frames_postion = 0;
-    } else {
-        aml_out->last_frames_postion = aml_out->frame_write_sum;
-    }
-
+    aml_out->last_frames_postion = aml_out->frame_write_sum;
     ALOGV("%s(), frame write sum %lld", __func__, aml_out->frame_write_sum);
     return bytes;
 }
@@ -1291,8 +1260,10 @@
         if (aml_dev->audio_patching) {
             ALOGV("%s(), tv patching, mixer_aux_buffer_write!", __FUNCTION__);
             aml_out->write = mixer_aux_buffer_write;
+            aml_out->write_func = MIXER_AUX_BUFFER_WRITE;
         } else {
             aml_out->write = mixer_aux_buffer_write_sm;
+            aml_out->write_func = MIXER_AUX_BUFFER_WRITE_SM;
             ALOGV("%s(), mixer_aux_buffer_write_sm !", __FUNCTION__);
         }
     } else if (STREAM_PCM_MMAP == aml_out->usecase) {
@@ -1544,11 +1515,13 @@
         aml_out->stream.write = out_write_subMixingPCM;
         aml_out->stream.common.standby = out_standby_subMixingPCM;
         out_standby_subMixingPCM((struct audio_stream *)aml_out);
+        aml_out->write_func = MIXER_AUX_BUFFER_WRITE_SM;
     } else {
-        aml_out->stream.write = mixer_aux_buffer_write;
+        aml_out->stream.write = out_write_new;//mixer_aux_buffer_write;
         aml_out->stream.common.standby = out_standby_new;
         deleteSubMixingInputPcm(aml_out);
         out_standby_new((struct audio_stream *)aml_out);
+        aml_out->write_func = OUT_WRITE_NEW;
     }
 
     return 0;
diff --git a/audio/libamlaudiohal/aml_port_dvb/Aml_DVB_Audio.cpp b/audio/libamlaudiohal/aml_port_dvb/Aml_DVB_Audio.cpp
index 895ee87..f484383 100644
--- a/audio/libamlaudiohal/aml_port_dvb/Aml_DVB_Audio.cpp
+++ b/audio/libamlaudiohal/aml_port_dvb/Aml_DVB_Audio.cpp
@@ -15,7 +15,7 @@
       sprintf (temp_buf, "fmt=%d", fmt);
       aml_audioport->setParameters(String8(temp_buf));
       memset(temp_buf,0,sizeof(temp_buf));
-      sprintf (temp_buf, "has_video=%d", has_video);
+      sprintf (temp_buf, "has_dtv_video=%d", has_video);
       aml_audioport->setParameters(String8(temp_buf));
       aml_audioport->setParameters(String8("cmd=1"));
    } else {
diff --git a/audio/utils/alsa_device_parser.c b/audio/utils/alsa_device_parser.c
index 5565d94..22a35cd 100644
--- a/audio/utils/alsa_device_parser.c
+++ b/audio/utils/alsa_device_parser.c
@@ -213,8 +213,6 @@
 
 				if (!strncmp(PortName, ALSAPORT_PCM, strlen(ALSAPORT_PCM)))
 					p_info->pcm_descrpt = mAudioDeviceDescriptor;
-				else if (!strncmp(PortName, ALSAPORT_I2S2HDMI, strlen(ALSAPORT_I2S2HDMI)))
-					p_info->i2s2hdmi_descrpt = mAudioDeviceDescriptor;
 				else if (!strncmp(PortName, ALSAPORT_I2SPLAYPLAYBACK, strlen(ALSAPORT_I2SPLAYPLAYBACK)))
 					p_info->i2s1_descrpt = mAudioDeviceDescriptor;
 				else if (!strncmp(PortName, ALSAPORT_I2SCAPTURE, strlen(ALSAPORT_I2SCAPTURE)))
@@ -250,23 +248,6 @@
 	}
 }
 
-static void dump_alsa_device_desc(struct alsa_info *p_info)
-{
-	ALOGD("%s %s: %p", __func__, ALSAPORT_PCM, p_info->pcm_descrpt);
-	ALOGD("%s %s: %p", __func__, ALSAPORT_I2S, p_info->i2s_descrpt);
-	ALOGD("%s %s: %p", __func__, ALSAPORT_I2SPLAYPLAYBACK, p_info->i2s1_descrpt);
-	ALOGD("%s %s: %p", __func__, ALSAPORT_I2SCAPTURE, p_info->i2s2_descrpt);
-	ALOGD("%s %s: %p", __func__, ALSAPORT_TDM, p_info->tdm_descrpt);
-	ALOGD("%s %s: %p", __func__, ALSAPORT_PDM, p_info->pdm_descrpt);
-	ALOGD("%s %s: %p", __func__, ALSAPORT_SPDIF, p_info->spdif_descrpt);
-	ALOGD("%s %s: %p", __func__, ALSAPORT_SPDIFB, p_info->spdifb_descrpt);
-	ALOGD("%s %s: %p", __func__, ALSAPORT_I2S2HDMI, p_info->i2s2hdmi_descrpt);
-	ALOGD("%s %s: %p", __func__, ALSAPORT_TV, p_info->tvin_descrpt);
-	ALOGD("%s %s: %p", __func__, ALSAPORT_LPBK, p_info->lpbk_descrpt);
-	ALOGD("%s %s: %p", __func__, ALSAPORT_BUILTINMIC, p_info->builtinmic_descrpt);
-	ALOGD("%s %s: %p", __func__, ALSAPORT_EARC, p_info->earc_descrpt);
-}
-
 /*
  * alsaPORT is kept same with meson sound card
  * cat /proc/asound/pcm
@@ -305,8 +286,6 @@
 			}
 			ALOGD("reach EOF");
 			fclose(mPcmFile);
-			if (0)
-				dump_alsa_device_desc(p_info);
 			p_info->deviced_checked = 1;
 		} else
 			ALOGD("Pcm open fail");
